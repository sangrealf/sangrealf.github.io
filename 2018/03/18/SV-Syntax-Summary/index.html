<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-flash.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="System Verilog,SV,语法,">










<meta name="description" content="此篇简要复习总结下SV的语法要点。 这里先放个最新的IEEE 1800-2017的标准，所有的细节可以在这里找到。  链接: https://pan.baidu.com/s/12XN6WJH4X9ss_PiqGuD5lw 密码: 3snd   数据类型    / 二值逻辑 四值逻辑     无符号 bit logic、reg、net-type（如wire、tri）   有符号 byte、short">
<meta name="keywords" content="System Verilog,SV,语法">
<meta property="og:type" content="article">
<meta property="og:title" content="SV Syntax Summary">
<meta property="og:url" content="http://www.syq.wiki/2018/03/18/SV-Syntax-Summary/index.html">
<meta property="og:site_name" content="ICer 杂记">
<meta property="og:description" content="此篇简要复习总结下SV的语法要点。 这里先放个最新的IEEE 1800-2017的标准，所有的细节可以在这里找到。  链接: https://pan.baidu.com/s/12XN6WJH4X9ss_PiqGuD5lw 密码: 3snd   数据类型    / 二值逻辑 四值逻辑     无符号 bit logic、reg、net-type（如wire、tri）   有符号 byte、short">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://p5mgt22l9.bkt.clouddn.com/%E5%AE%9A%E5%AE%BD%E6%95%B0%E7%BB%84.png">
<meta property="og:image" content="http://p5mgt22l9.bkt.clouddn.com/%E5%85%B3%E8%81%94%E6%95%B0%E7%BB%84.png">
<meta property="og:image" content="http://p5mgt22l9.bkt.clouddn.com/%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF.png">
<meta property="og:image" content="http://p5mgt22l9.bkt.clouddn.com/forkjoin.png">
<meta property="og:image" content="http://p5mgt22l9.bkt.clouddn.com/%E8%A6%86%E7%9B%96%E7%8E%87%E5%8F%8D%E9%A6%88%E5%9B%9E%E8%B7%AF.png">
<meta property="og:image" content="http://p5mgt22l9.bkt.clouddn.com/%E9%AA%8C%E8%AF%81%E7%9A%84%E5%AE%8C%E5%A4%87%E6%80%A7.png">
<meta property="og:updated_time" content="2018-03-28T16:23:50.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="SV Syntax Summary">
<meta name="twitter:description" content="此篇简要复习总结下SV的语法要点。 这里先放个最新的IEEE 1800-2017的标准，所有的细节可以在这里找到。  链接: https://pan.baidu.com/s/12XN6WJH4X9ss_PiqGuD5lw 密码: 3snd   数据类型    / 二值逻辑 四值逻辑     无符号 bit logic、reg、net-type（如wire、tri）   有符号 byte、short">
<meta name="twitter:image" content="http://p5mgt22l9.bkt.clouddn.com/%E5%AE%9A%E5%AE%BD%E6%95%B0%E7%BB%84.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":true,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: 'C2YCDEVUOD',
      apiKey: '',
      indexName: 'sangrealf',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>







  <title>SV Syntax Summary | ICer 杂记</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?033775e6ec79969a2c30c8c40ba32d03";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">ICer 杂记</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Sangrealf 的个人博客</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-categories" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.syq.wiki/2018/03/18/SV-Syntax-Summary/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sangrealf">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/touxiang.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ICer 杂记">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">SV Syntax Summary</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-18T15:15:45+08:00">
                2018-03-18
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/study/" itemprop="url" rel="index">
                    <span itemprop="name">学习笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>
            </span>
          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>此篇简要复习总结下SV的语法要点。
这里先放个最新的IEEE 1800-2017的标准，所有的细节可以在这里找到。</p>
<ul>
<li>链接: <a href="https://pan.baidu.com/s/12XN6WJH4X9ss_PiqGuD5lw" target="_blank" rel="noopener">https://pan.baidu.com/s/12XN6WJH4X9ss_PiqGuD5lw</a></li>
<li>密码: 3snd</li>
</ul>
<hr>
<h2 id="数据类型">数据类型</h2>
<table>
<thead>
<tr>
<th style="text-align:center">/</th>
<th style="text-align:center">二值逻辑</th>
<th style="text-align:center">四值逻辑</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">无符号</td>
<td style="text-align:center">bit</td>
<td style="text-align:center">logic、reg、net-type（如wire、tri）</td>
</tr>
<tr>
<td style="text-align:center">有符号</td>
<td style="text-align:center">byte、shortint、int、longint</td>
<td style="text-align:center">intrger</td>
</tr>
</tbody>
</table>
<p><strong>尽量避免两种不一致的变量进行操作，而导致意外的错误</strong></p>
<p><strong>在不同数据类型进行操作时应该注意变量的逻辑数值类型、符号类型以及矢量位宽</strong></p>
<ul>
<li>静态转换  <code>unsigned_vec = unsigned'(signed_vec);</code></li>
<li>动态转换  <code>$cast(tgt, src)</code></li>
</ul>
<hr>
<h3 id="定宽数组">定宽数组</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bit</span> [<span class="number">3</span>][<span class="number">7</span>:<span class="number">0</span>] b_pack;</span><br><span class="line"><span class="keyword">bit</span> [<span class="number">7</span>:<span class="number">0</span>] b_unpack[<span class="number">3</span>];</span><br></pre></td></tr></table></figure>
<p><img src="http://p5mgt22l9.bkt.clouddn.com/%E5%AE%9A%E5%AE%BD%E6%95%B0%E7%BB%84.png" alt="此处输入图片的描述"></p>
<p><em>由上图可见b_unpack实际会占据3个WORD的存储空间，而b_pack则只会占据1个WORD的存储空间</em></p>
<hr>
<h3 id="动态数组">动态数组</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> dyn[], dyn2[]; <span class="comment">// 声明动态数组</span></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    dyn = <span class="keyword">new</span>[<span class="number">5</span>]; <span class="comment">// 分配5个元素</span></span><br><span class="line">    <span class="keyword">foreach</span> (dyn[j]) dyn[j] = j; <span class="comment">// 对元素初始化</span></span><br><span class="line">    dyn2 = dyn; <span class="comment">// 复制一个动态数组</span></span><br><span class="line">    dyn2[<span class="number">0</span>] = <span class="number">5</span>; <span class="comment">// 修改复制值</span></span><br><span class="line">    <span class="built_in">$display</span>(dyn[<span class="number">0</span>],dyn2[<span class="number">0</span>]); <span class="comment">// 显示数值0和5</span></span><br><span class="line">    dyn = <span class="keyword">new</span>[<span class="number">20</span>](dyn); <span class="comment">// 分配20个数值并进行复制</span></span><br><span class="line">    dyn = <span class="keyword">new</span>[<span class="number">100</span>]; <span class="comment">// 重新分配100个数值，而旧值不复存在</span></span><br><span class="line">    dyn<span class="variable">.delete</span>(); <span class="comment">// 删除所有元素</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="队列">队列</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> j = <span class="number">1</span>, q2[$] = &#123;<span class="number">3</span>,<span class="number">4</span>&#125;, q[$] = &#123;<span class="number">0</span>,<span class="number">2</span>,<span class="number">5</span>&#125;; <span class="comment">// 队列复制不使用“ ‘ ”</span></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    q<span class="variable">.insert</span>(<span class="number">1</span>, j); <span class="comment">// &#123;0,1,2,5&#125; 在2前插入1</span></span><br><span class="line">    q<span class="variable">.insert</span>(<span class="number">3</span>, q2); <span class="comment">// &#123;0,1,2,3,4,5&#125; 在q中插入队列q2</span></span><br><span class="line">    q<span class="variable">.delete</span>(<span class="number">1</span>); <span class="comment">// &#123;0,2,3,4,5&#125; 删除第一个元素</span></span><br><span class="line">    <span class="comment">// 下列操作运行速度更快（自有方法）</span></span><br><span class="line">    q<span class="variable">.push_front</span>(<span class="number">6</span>); <span class="comment">// &#123;6,0,2,3,4,5&#125; 在队列头部插入</span></span><br><span class="line">    j = q<span class="variable">.pop_back</span>(); <span class="comment">// &#123;6,0,2,3,4&#125; 从队列尾部取出</span></span><br><span class="line">    q<span class="variable">.push_back</span>(<span class="number">8</span>); <span class="comment">// &#123;6,0,2,3,4,8&#125; 从队列尾部插入</span></span><br><span class="line">    j = q<span class="variable">.pop_front</span>(); <span class="comment">// &#123;0,2,3,4,8&#125; 从队列头部取出</span></span><br><span class="line">    <span class="keyword">foreach</span> (q[i])</span><br><span class="line">        <span class="built_in">$display</span>(q[i]); <span class="comment">// 打印整个队列</span></span><br><span class="line">    q<span class="variable">.delete</span>(); <span class="comment">// &#123;&#125; 删除整个队列</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="关联数组">关联数组</h3>
<p><img src="http://p5mgt22l9.bkt.clouddn.com/%E5%85%B3%E8%81%94%E6%95%B0%E7%BB%84.png" alt="此处输入图片的描述"></p>
<p><em>可以用来保存稀疏矩阵的元素，灵活赋予key和对应的value，类似perl的hash或python的dictionary</em></p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bit</span> [<span class="number">63</span>:<span class="number">0</span>] assoc[<span class="keyword">int</span>], idx = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">repeat</span> (<span class="number">64</span>) <span class="keyword">begin</span> <span class="comment">// 对稀疏分布的元素进行初始化</span></span><br><span class="line">    assoc[idx] = idx;</span><br><span class="line">    idx = idx &lt;&lt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">foreach</span> (assoc[i]) <span class="comment">// 使用 foreach遍历数组</span></span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">"assoc[%h] = %h"</span>, i, assoc[i]);</span><br><span class="line"><span class="comment">// 使用函数遍历数组</span></span><br><span class="line"><span class="keyword">if</span> (assoc<span class="variable">.first</span>(idx)) <span class="keyword">begin</span> <span class="comment">// 得到第一个索引</span></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">"assoc[%h]=%h"</span>, idx, assoc[idx]);</span><br><span class="line">    <span class="keyword">while</span> (assoc<span class="variable">.next</span>(idx)); <span class="comment">// Get next index</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">// 找到并删除第一个元素</span></span><br><span class="line">assoc<span class="variable">.first</span>(idx);</span><br><span class="line">assoc<span class="variable">.delete</span>(idx);</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="结构体-枚举-typedef">结构体、枚举、typedef</h3>
<p><em>与C类似</em></p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> &#123;<span class="keyword">bit</span> [<span class="number">7</span>:<span class="number">0</span>] r, g, b;&#125; pixel; <span class="comment">// 创建一个pixel结构体</span></span><br><span class="line"><span class="comment">//为了共享该类型，通过typedef来创建新类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;<span class="keyword">bit</span> [<span class="number">7</span>:<span class="number">0</span>] r, g, b;&#125; pixel_s; </span><br><span class="line">pixel_s my_pixel; <span class="comment">// 声明变量</span></span><br><span class="line">my_pixel = ‘&#123;‘h10, ‘h10, ‘h10&#125;; <span class="comment">//结构体类型的赋值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;INIT, DECODE, IDLE&#125; fsmstate_e;</span><br><span class="line">fsmstate_e pstate, nstate; <span class="comment">// 声明自定义类型变量</span></span><br><span class="line"><span class="keyword">case</span> (pstate)</span><br><span class="line">    IDLE: nstate = INIT; <span class="comment">// 数值赋值</span></span><br><span class="line">    INIT: nstate = DECODE;</span><br><span class="line">    <span class="keyword">default</span>: nstate = IDLE;</span><br><span class="line"><span class="keyword">endcase</span></span><br><span class="line"><span class="built_in">$display</span>(“Next state is %s”, nstate<span class="variable">.name</span>()); <span class="comment">// 显示状态名</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="字符串">字符串</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">string</span> s;</span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    s = <span class="string">"IEEE "</span>;</span><br><span class="line">    <span class="built_in">$display</span>(s<span class="variable">.getc</span>(<span class="number">0</span>)); <span class="comment">// 显示 ‘I’</span></span><br><span class="line">    <span class="built_in">$display</span>(s<span class="variable">.tolower</span>()); <span class="comment">// 显示 ieee</span></span><br><span class="line">    s<span class="variable">.putc</span>(s<span class="variable">.len</span>()-<span class="number">1</span>, “-”); <span class="comment">// 将空格变为‘-’</span></span><br><span class="line">    s = &#123;s, <span class="string">"P1800"</span>&#125;; <span class="comment">// "IEEE-P1800"</span></span><br><span class="line">    <span class="built_in">$display</span>(s<span class="variable">.substr</span>(<span class="number">2</span>, <span class="number">5</span>)); <span class="comment">// 显示 EE-P</span></span><br><span class="line">    <span class="comment">// 创建一个临时字符串并将其打印</span></span><br><span class="line">    my_log(<span class="built_in">$sformatf</span>(<span class="string">"%s %5d"</span>, s, <span class="number">42</span>)); <span class="comment">//格式化函数</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">task</span> my_log(<span class="keyword">string</span> message); <span class="comment">// 打印消息</span></span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">"@%0t: %s"</span>, <span class="built_in">$time</span>, message);</span><br><span class="line"><span class="keyword">endtask</span></span><br></pre></td></tr></table></figure>
<p><em>string的内置函数</em></p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="keyword">int</span> len()  <span class="comment">//str.len()返回字符串str的字符长度</span></span><br><span class="line"><span class="keyword">function</span> <span class="keyword">void</span> putc(<span class="keyword">int</span> i, <span class="keyword">byte</span> c)  <span class="comment">//str.putc(i, c)将字符串str的第i个字符替换为c</span></span><br><span class="line"><span class="keyword">function</span> <span class="keyword">byte</span> getc(<span class="keyword">int</span> i)  <span class="comment">//str.getc(i)返回字符串str的第i个字符的ASCII码</span></span><br><span class="line"><span class="keyword">function</span> <span class="keyword">string</span> toupper()  <span class="comment">//str.toupper()将字符串str转换为大写</span></span><br><span class="line"><span class="keyword">function</span> <span class="keyword">string</span> tolower()  <span class="comment">//str.tolower()将字符串str转换为小写</span></span><br><span class="line"><span class="keyword">function</span> <span class="keyword">int</span> compare(<span class="keyword">string</span> s)  <span class="comment">//str.compare(s)比较字符串str和s，类似ANSI C的strcmp函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="keyword">int</span> icompare(<span class="keyword">string</span> s)  <span class="comment">//str.icompare(s)类似compare函数，大小写敏感</span></span><br><span class="line"><span class="keyword">function</span> <span class="keyword">string</span> substr(<span class="keyword">int</span> i, <span class="keyword">int</span> j)  <span class="comment">//str.substr(i, j)返回字符串str的i到i+j字段</span></span><br><span class="line"><span class="keyword">function</span> <span class="keyword">integer</span> atoi()  <span class="comment">//str.atoi()将字符串str转换为十进制数值</span></span><br><span class="line"><span class="keyword">function</span> <span class="keyword">integer</span> atohex()  <span class="comment">//str.atohex()将字符串str转换为十六进制数值</span></span><br><span class="line"><span class="keyword">function</span> <span class="keyword">integer</span> atooct()  <span class="comment">//str.atooct()将字符串str转换为八进制数值</span></span><br><span class="line"><span class="keyword">function</span> <span class="keyword">integer</span> atobin()  <span class="comment">//str.atobin()将字符串str转换为二进制数值</span></span><br><span class="line"><span class="keyword">function</span> <span class="keyword">real</span> atoreal()  <span class="comment">//str.atoreal()将字符串str转换为实数类型数值</span></span><br><span class="line"><span class="keyword">function</span> <span class="keyword">void</span> itoa(<span class="keyword">integer</span> i)  <span class="comment">//str.itoa(i)将十进制数值i转换为字符串类型，atoi的反函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="keyword">void</span> hextoa(<span class="keyword">integer</span> i)  <span class="comment">//str.hextoa(i)将十六进制数值i转换为字符串类型，atohex的反函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="keyword">void</span> octtoa(<span class="keyword">integer</span> i)  <span class="comment">//str.octtoa(i)将八进制数值i转换为字符串类型，atooct的反函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="keyword">void</span> bintoa(<span class="keyword">integer</span> i)  <span class="comment">//str.bintoa(i)将二进制数值i转换为字符串类型，atobin的反函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="keyword">void</span> realtoa(<span class="keyword">real</span> r)  <span class="comment">//str.itoa(i)将实数数值转换为字符串类型，atoreal的反函数</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="design-element">Design Element</h2>
<p>SV里的design element有<code>module</code>, <code>program</code>, <code>interface</code>, <code>checker</code>, <code>package</code>, <code>primitive</code>和<code>config</code>等</p>
<hr>
<h3 id="module">module</h3>
<p><em>主要用于实现设计模块，当然也可以包括验证模块和设计/验证模块的连接部分</em></p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> mux2to1 (<span class="keyword">input</span> <span class="keyword">wire</span> a, b, sel, <span class="comment">//将port和类型声明放到一起</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">logic</span> y);</span><br><span class="line">    <span class="keyword">always_comb</span> <span class="keyword">begin</span> <span class="comment">//过程块</span></span><br><span class="line">        <span class="keyword">if</span> (sel) y = a;</span><br><span class="line">        <span class="keyword">else</span> y = b;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span>: mux2to1</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="program">program</h3>
<p><em>用于建模testbench环境，其重点不是描述硬件细节，如wire，结构层次，模块连接等，而主要用于软件建模，其基本目的</em></p>
<ul>
<li>提供testbench仿真运行的入口</li>
<li>封装软件scope的data、task和function等</li>
<li>其语义指定了仿真的调度，配合clocking块，可以保证仿真的race-free，如</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">clocking</span> bus @(<span class="keyword">posedge</span> clock);</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">input</span> #<span class="number">10</span>ns <span class="keyword">output</span> #<span class="number">2</span>ns; <span class="comment">//如未定义，则会默认地在clocking采样事件前的1step对输入进行采样，在采样事件后的#0对输出进行驱动</span></span><br><span class="line">    <span class="keyword">input</span> data, ready, enable；  </span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">negedge</span> ack;</span><br><span class="line">    <span class="keyword">input</span> #<span class="number">1</span>step addr;</span><br><span class="line"><span class="keyword">endclocking</span></span><br></pre></td></tr></table></figure>
<p>clocking块除了program外，也可以定义在interface或module中</p>
<p><em>program块可以包括</em></p>
<ul>
<li>data声明</li>
<li>class定义</li>
<li>子函数定义</li>
<li>object实例</li>
<li>一或多个intial或final块（<strong>当所有program中最后一个initial块完成后，隐式结束仿真。也可置入系统函数$exit()强行结束当前program</strong>）</li>
</ul>
<p><em>program块</em><em>不</em><em>可以包括</em></p>
<ul>
<li>always块</li>
<li>primitive实例</li>
<li>module实例</li>
<li>interface实例</li>
<li>其它program实例</li>
</ul>
<p>program的引入将硬件和软件scope分开，可以更方便地创建和维护testbench</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">program</span> test (<span class="keyword">input</span> clk, <span class="keyword">input</span> [<span class="number">16</span>:<span class="number">1</span>] addr, <span class="keyword">inout</span> [<span class="number">7</span>:<span class="number">0</span>] data);</span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">endprogram</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="interface">interface</h3>
<p><em>用于连接design模块，或者design和testbench</em>
<em>modport可以提供方向信息，顾名思义，其方向是从module视角看到的方向</em>
<em>可以包含parameter，constant，variable，task和function等。也可以包含process（如initial或always块）和连续赋值等，这个在系统建模时有用，譬如可以让interface包含其协议的checker，function coverage，assertion等，这样可以验证所有使用该interface连接的各个模块的接口协议</em></p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> simple_bus(<span class="keyword">input</span> <span class="keyword">logic</span> clk); <span class="comment">//定义接口</span></span><br><span class="line">    <span class="keyword">logic</span> req, gnt;</span><br><span class="line">    <span class="keyword">logic</span> [<span class="number">7</span>:<span class="number">0</span>] addr, data;</span><br><span class="line">    <span class="keyword">logic</span> [<span class="number">1</span>:<span class="number">0</span>] mode;</span><br><span class="line">    <span class="keyword">logic</span> start, rdy;</span><br><span class="line"><span class="keyword">endinterface</span>: simple_bus</span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> memMod(simple_bus a); <span class="comment">//simple_bus接口</span></span><br><span class="line">    <span class="keyword">logic</span> avail;</span><br><span class="line">    <span class="comment">//信号在'simple_bus'类型接口的sb_intf实例</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> a<span class="variable">.clk</span>)</span><br><span class="line">        a<span class="variable">.gnt</span> &lt;= a<span class="variable">.req</span> &amp; avail;</span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> cpuMod(simple_bus b); <span class="comment">//simple_bus接口</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> top;</span><br><span class="line">    <span class="keyword">logic</span> clk = <span class="number">0</span>;</span><br><span class="line">    simple_bus sb_intf(<span class="variable">.clk</span>(clk)); <span class="comment">//实例化接口</span></span><br><span class="line">    memMod mem(<span class="variable">.a</span>(sb_intf)); <span class="comment">//连接接口和模块实例</span></span><br><span class="line">    cpuMod cpu(<span class="variable">.b</span>(sb_intf)); <span class="comment">//连接接口和模块实例</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="checker">checker</h3>
<p><em>封装assertion，可以作为验证库单元或作为创建用于formal验证的抽象模型</em></p>
<hr>
<h3 id="primitive">primitive</h3>
<p><em>用于建模low level的logic gate或switch。SV已包含了许多内置的primitive，用户可以用UDP(user defined primitive)进行gate level建模</em></p>
<hr>
<h3 id="subroutine">subroutine</h3>
<p><em>封装代码以实现复用</em></p>
<h4 id="task">task</h4>
<p>可以有任意数量的input，output，inout和ref参数，但不能有返回值，可以包含耗时语句</p>
<h4 id="function">function</h4>
<p>可以为void或有返回值，不可以包含耗时语句</p>
<hr>
<h3 id="package">package</h3>
<p><em>module，interface，program，checker等仅提供了声明的local name space，package的引入可以让其他模块共享package中包含的内容，package可以包含其它package</em></p>
<ul>
<li>在包中可以定义类、静态方法和静态变量</li>
<li>如果将类封装在某一个包中，那么它就不应该在其它地方编译，这么做的好处在于之后对类的引用更加方便</li>
<li>一个完整模块的验证环境组件类，应该由一个对应的模块包来封装</li>
<li>使用`include的关键词完成类在包中的封装，要注意编译的前后顺序来放置各个`include的类文件</li>
<li>编译一个包的背后实际是将各个类文件“平铺”在包中，按照顺序完成包和各个类的有序编译</li>
<li>使用类可以通过import完成包中所有类或者某一个类的导入，使得新的环境可以识别出该类，否则类会在包这个盒子里不被外部识别</li>
</ul>
<hr>
<h3 id="config">config</h3>
<p><em>对于编译的module、interface和package这些硬件和软件，如果没有额外的指定，会被编译到默认的library(work)中。在默认库中各个module是互相识别的，当然module也识别同一个library中的package。如果要使用其他library中的module或者package，可以用config文件指定</em></p>
<hr>
<h2 id="class">class</h2>
<p><em>SV的class定义与Verilog的module+method的方式有本质的差别，即面向对象编程的三要素：封装（Encapsulation）、继承（Inheritance）和多态（Polymorphism）</em>
<em>类的定义核心即是属性声明（property declaration）和方法定义（method definition），所以类是数据和方法的自洽体（self-compatible），即可以保存数据和处理数据。这是与struct结构体在数据保存方面的重要区别，因为结构体只是单纯的数据集合，而类则可以对数据做出符合需要的处理</em></p>
<hr>
<h3 id="创建对象">创建对象</h3>
<h4 id="verilog的例化和sv-class例化的差别">Verilog的例化和SV class例化的差别</h4>
<ul>
<li>两者的共同点在于使用相同的‘模板’来创建内存实例</li>
<li>不同点在于Verilog的例化是静态的，即在编译链接时完成，而SV class的例化是动态的，可以在任意时间点发生，这也使得类的例化方式更加灵活和节省空间</li>
<li>Verilog中没有句柄的概念，即只能通过层次化的索引方式A.B.sigX，而SV class通过句柄可以将对象的指针赋予其它句柄，使得操作更加灵活。</li>
</ul>
<hr>
<h4 id="构造函数">构造函数</h4>
<ul>
<li>声明并不会隐式的调用构造函数，只会生成一个句柄变量，需要显式的调用new函数才会产生一个对象</li>
<li>构造函数new()必须是无阻塞的，每个类都有一个内建的new()函数，其将调用super.new()，然后初始化类的属性和对象</li>
<li>sv自动回收内存空间（不需析构函数），当某一对象没有任一句柄指向它时，便会被回收销毁</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Transaction tr1, tr2; <span class="comment">// 声明句柄，初始值为null</span></span><br><span class="line">tr1 = <span class="keyword">new</span>(); <span class="comment">// 创建对象，即例化，为一个Transaction对象分配空间，将变量初始化为默认值，二值--&gt;0，四值--&gt;x并返回保存对象的地址。将该对象的句柄赋予tr1</span></span><br><span class="line">tr2 = tr1; <span class="comment">// 将tr1的值赋予tr2，即tr2和tr1指向同一个对象</span></span><br><span class="line">tr1 = <span class="keyword">new</span>(); <span class="comment">// 例化第二个对象，并将其句柄赋予tr1</span></span><br><span class="line">tr2 = <span class="keyword">new</span>(); <span class="comment">// 例化第三个对象，并将其句柄赋予tr2，tr2之前指向的第一个对象被释放</span></span><br><span class="line">tr1 = <span class="literal">null</span>; <span class="comment">// 将tr1赋值为空即不指向任何对象（悬空的指针很危险！）</span></span><br></pre></td></tr></table></figure>
<hr>
<h4 id="静态变量和方法">静态变量和方法</h4>
<ul>
<li>SV的class中声明的变量默认类型为动态变量，其生命周期始于对象创建，终于对象销毁</li>
<li>如果使用关键字static来声明class内的变量，则其为静态变量。其生命开始于编译阶段，贯穿于整个仿真阶段</li>
<li>如果在类中声明了静态变量，那么可以直接引用该变量class::var，或者通过例化对象引用object.var。类中的静态变量声明以后，无论例化多少个对象（0..N），只可以共享一个同名的静态变量，因此类的静态变量在使用时需要注意共享资源的保护</li>
<li>类似于静态变量，在class中定义的方法默认类型是动态方法，也可以通过关键词static修改其类型为静态方法。</li>
<li>静态方法内可以声明并使用动态变量，但是不能使用类的动态成员变量。因为在调用静态方法时，可能并没有创建具体的对象，因此没有为动态成员变量开辟空间，所以在静态方法中使用类的动态成员变量是禁止的，可能会造成内存泄漏，但是静态方法可以使用类的静态变量，因为静态方法同静态变量一样在编译阶段就已经为其分配好了内存空间</li>
</ul>
<hr>
<h3 id="类的成员">类的成员</h3>
<ul>
<li>
<p>如果没有指明访问类型，那么成员的默认类型是public，子类和外部均可以访问成员</p>
</li>
<li>
<p>如果指明了访问类型是protected，那么只有该类或者子类可以访问成员，而外部无法访问</p>
</li>
<li>
<p>如果指明了访问类型是local，那么只有该类可以访问成员，子类和外部均无法访问</p>
</li>
<li>
<p>如果在类中使用this，即表明this.X所调用的成员是当前类的成员，而非同名的局部变量或者形式参数等</p>
</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">string</span> name);</span><br><span class="line">    <span class="keyword">this</span><span class="variable">.name</span> = name;</span><br><span class="line"><span class="keyword">endfunction</span></span><br></pre></td></tr></table></figure>
<ul>
<li>关于类的编译顺序，应该先编译基本类，再编译高级类。或者说，先编译将来被引用的类，再编译引用之前已编译类的类。</li>
</ul>
<hr>
<h3 id="类的继承-inheritance">类的继承(Inheritance)</h3>
<ul>
<li>扩展类拥有基类的一切变量与方法，在扩展类中调用基类的变量与函数，可以通过super.+变量/方法来调用。在扩展类的构造函数中，应该先对基类先进行new函数</li>
<li>在扩展类的对象中调用对象时，SV比较句柄的类型来决定调用的是基类function还是扩展类function。但是当function是virtual类型时，SV会根据对象的类型来决定调用基类function还是扩展类function。推荐在需要扩展的基类中使用virtual function的形式，这样符合OOP的多态概念，也有利于向下转换</li>
<li>默认情况下，如果没有super或者this来指示作用域，则依照从近到远的原则来引用变量即</li>
</ul>
<ol>
<li>首先看变量是否是函数内部定义的局部变量</li>
<li>其次看变量是否是当前类定义的成员变量</li>
<li>最后再看变量是否是父类或者更底层类的变量</li>
</ol>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Transaction;</span><br><span class="line">    <span class="keyword">rand</span> <span class="keyword">bit</span> [<span class="number">31</span>:<span class="number">0</span>] src, dst, data[<span class="number">8</span>]; <span class="comment">// 随机成员变量</span></span><br><span class="line">    <span class="keyword">bit</span> [<span class="number">31</span>:<span class="number">0</span>] crc; <span class="comment">// 二次处理后的成员数据</span></span><br><span class="line">    <span class="keyword">virtual</span> <span class="keyword">function</span> <span class="keyword">void</span> calc_crc（）;</span><br><span class="line">        crc = src ^ dst ^ data<span class="variable">.xor</span>;</span><br><span class="line">    <span class="keyword">endfunction</span></span><br><span class="line">    <span class="keyword">virtual</span> <span class="keyword">function</span> <span class="keyword">void</span> display(<span class="keyword">input</span> <span class="keyword">string</span> prefix=<span class="string">""</span>);</span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">"%sTr: src=%h, dst=%h, crc=%h"</span>, prefix, src, dst, crc);</span><br><span class="line">    <span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span> : Transaction</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> BadTr <span class="keyword">extends</span> Transaction;</span><br><span class="line">    <span class="keyword">rand</span> <span class="keyword">bit</span> bad_crc;</span><br><span class="line">    <span class="keyword">virtual</span> <span class="keyword">function</span> <span class="keyword">void</span> calc_crc;</span><br><span class="line">        <span class="keyword">super</span><span class="variable">.calc_crc</span>(); <span class="comment">// 计算正确的CRC</span></span><br><span class="line">        <span class="keyword">if</span> (bad_crc)</span><br><span class="line">            crc = ~crc; <span class="comment">// 生成错误的CRC</span></span><br><span class="line">    <span class="keyword">endfunction</span></span><br><span class="line">    <span class="keyword">virtual</span> <span class="keyword">function</span> <span class="keyword">void</span> display(<span class="keyword">input</span> <span class="keyword">string</span> prefix=<span class="string">""</span>);</span><br><span class="line">        <span class="built_in">$write</span>(<span class="string">"%sBadTr: bad_crc=%b, "</span>, prefix, bad_crc);</span><br><span class="line">        <span class="keyword">super</span><span class="variable">.display</span>();</span><br><span class="line">    <span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span> : BadTr</span><br><span class="line"></span><br><span class="line">Transaction  tr;</span><br><span class="line">Badtr bad;</span><br><span class="line"><span class="keyword">initial</span>  <span class="keyword">begin</span></span><br><span class="line">    tr = <span class="keyword">new</span> ();</span><br><span class="line">    tr<span class="variable">.calc_crc</span> (); <span class="comment">// 调用基类类型</span></span><br><span class="line">    bad = <span class="keyword">new</span>();</span><br><span class="line">    bad<span class="variable">.calc_crc</span> (); <span class="comment">// 调用扩展类类型</span></span><br><span class="line"></span><br><span class="line">    tr = bad; <span class="comment">// 基类句柄可以直接指向扩展类对象</span></span><br><span class="line">    tr<span class="variable">.calc_crc</span> (); <span class="comment">// 由对象类型来决定，所以调用BadTr.calc_crc</span></span><br><span class="line">    <span class="built_in">$cast</span>(bad , tr); <span class="comment">// 将指向扩展类对象的基类句柄指向扩展类句柄。只有这种情况下，可以成功，$cast非零</span></span><br><span class="line">    bad<span class="variable">.calc_crc</span> (); <span class="comment">// 由对象类型决定，所以调用BadTr.cac_crc</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p><img src="http://p5mgt22l9.bkt.clouddn.com/%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF.png" alt="此处输入图片的描述"></p>
<hr>
<h2 id="线程的控制和同步">线程的控制和同步</h2>
<h3 id="线程的控制">线程的控制</h3>
<ul>
<li>
<p>线程即独立运行的程序</p>
</li>
<li>
<p>线程需要被触发，可以结束或者不结束</p>
</li>
<li>
<p>线程的执行轨迹是呈树状结构的，即任何的线程都应该有父线程</p>
</li>
<li>
<p>父线程可以开辟若干个子线程，父线程可以暂停或者终止子线程</p>
</li>
<li>
<p>当子线程终止时，父线程可以继续执行</p>
</li>
<li>
<p>当父线程终止时，其所开辟的所有子线程都应当会终止</p>
</li>
<li>
<p>在module中的initial和always，都可以看做独立的线程，它们会在仿真0时刻开始，而选择结束或者不结束</p>
</li>
<li>
<p>硬件模型中由于都是always语句块，所以可以看成是多个独立运行的线程，而这些线程会一直占用仿真资源，因为它们并不会结束</p>
</li>
<li>
<p>软件测试平台中的验证环境都需要由initial语句块去创建，而在仿真过程中，验证环境中的对象可以创建和销毁，因此软件测试端的资源占用是动态的</p>
</li>
<li>
<p>软件环境中的initial块对语句有两种分组方式，使用begin...end或fork...join</p>
</li>
<li>
<p>begin...end中的语句以顺序方式执行，而fork...join中的语句则以并发方式执行</p>
</li>
<li>
<p>与fork...join类似的并行方式语句还包括fork...join_any，fork...join_none
<img src="http://p5mgt22l9.bkt.clouddn.com/forkjoin.png" alt="此处输入图片的描述"></p>
</li>
<li>
<p>在使用了fork...join_any或者fork...join_none以后，我们可以使用disable来指定需要停止的线程</p>
</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">parameter</span> TIME_OUT = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">task</span> check_trans(Transaction tr);</span><br><span class="line">    <span class="keyword">fork</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 等待回应，或者达到某个最大时延</span></span><br><span class="line">            <span class="keyword">fork</span> : timeout_block</span><br><span class="line">            <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">wait</span> (bus<span class="variable">.cb</span><span class="variable">.addr</span> == tr<span class="variable">.addr</span>);</span><br><span class="line">                <span class="built_in">$display</span>(<span class="string">"@%0t: Addr match %d"</span>, <span class="built_in">$time</span>, tr<span class="variable">.addr</span>);</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            #TIME_OUT <span class="built_in">$display</span>(<span class="string">"@%0t: Error: timeout"</span>, <span class="built_in">$time</span>);</span><br><span class="line">            <span class="keyword">join_any</span></span><br><span class="line">            <span class="keyword">disable</span> timeout_block;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">join_none</span></span><br><span class="line"><span class="keyword">endtask</span></span><br></pre></td></tr></table></figure>
<ul>
<li>disable fork可以停止从当前线程中衍生出来的所有子线程</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    check_trans(tr0); <span class="comment">// 线程0</span></span><br><span class="line">    <span class="comment">// 创建一个线程来限制disable fork的作用范围</span></span><br><span class="line">    <span class="keyword">fork</span> <span class="comment">// 线程1</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            check_trans(tr1); <span class="comment">// 线程2</span></span><br><span class="line">            <span class="keyword">fork</span> <span class="comment">// 线程3</span></span><br><span class="line">                check_trans(tr2); <span class="comment">// 线程4</span></span><br><span class="line">            <span class="keyword">join</span></span><br><span class="line">            <span class="comment">// 停止线程1-4，单独保留线程0</span></span><br><span class="line">            <span class="variable">#(TIME_OUT/2)</span> <span class="keyword">disable</span> <span class="keyword">fork</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">join</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<ul>
<li>如果给某一个任务或者线程指明标号，那么当这个线程被调用多次以后，如果通过disable去禁止这个线程标号，所有衍生的同名线程都将被禁止</li>
</ul>
<hr>
<h3 id="线程的同步">线程的同步</h3>
<p>线程间的数据交换和同步</p>
<ul>
<li>测试平台中的所有线程都需要同步并交换数据</li>
<li>一个线程需要等待另一个</li>
<li>多个线程可能同时访问同一个资源</li>
<li>线程之间可能需要交换数据。</li>
</ul>
<h4 id="event事件">event事件</h4>
<ul>
<li>Verilog中，一个线程总是要等待一个带@操作符的事件。这个操作符是边沿敏感的，所以它总是阻塞着、等待事件的变化</li>
<li>其它线程可以通过-&gt;操作符来触发事件，结束对第一个线程的阻塞</li>
<li>可以使用电平敏感的wait(eventX.triggered())来替代边沿敏感的阻塞语句@eventX</li>
<li>如果事件在当前时刻已经被触发，则不会引起阻塞。否则，会一直等到事件被触发为止</li>
<li>这个方法比起@而言，更有能力保证，只要event被触发过，就可以防止引起阻塞</li>
<li>对于线程多次通知的需求，应该使用“@”，而无法使用wait(event.triggered)。这是由于，当一个event被触发之后，它的状态会使得event.triggered一直保持为true（1'b1）。不过，event没有方法可以清除event.triggered的状态</li>
</ul>
<hr>
<h4 id="spmaphore旗语">spmaphore旗语</h4>
<ul>
<li>semaphore可以实现对共享资源的访问控制</li>
<li>semaphore有三种基本操作。new()方法可以创建一个带单个或者多个钥匙的semaphore，使用get()可以获取一个或者多个钥匙，而put()可以返回一个或者多个钥匙</li>
<li>如果试图获取一个semaphore而不希望被阻塞，可以使用try_get()函数。其返回1表示有足够多的钥匙，而返回0则表示钥匙不够</li>
<li>对于线程间共享资源的使用方式，应该遵循互斥访问（mutex access）原则</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">program</span> <span class="keyword">automatic</span> test(bus_ifc<span class="variable">.TB</span> bus);</span><br><span class="line">    semaphore sem; <span class="comment">// 创建一个semaphore</span></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        sem = <span class="keyword">new</span>(<span class="number">1</span>); <span class="comment">// 分配一个钥匙</span></span><br><span class="line">        <span class="keyword">fork</span></span><br><span class="line">            sequencer(); <span class="comment">// 产生两个总线事务线程</span></span><br><span class="line">            sequencer(); </span><br><span class="line">        <span class="keyword">join</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">task</span> sequencer;</span><br><span class="line">        <span class="keyword">repeat</span>($urandom%<span class="number">10</span>) <span class="comment">// 随机等待0-9个周期</span></span><br><span class="line">        @bus<span class="variable">.cb</span>;</span><br><span class="line">        sendTrans(); <span class="comment">// 执行总线事务</span></span><br><span class="line">    <span class="keyword">endtask</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">task</span> sendTrans;</span><br><span class="line">        sem<span class="variable">.get</span>(<span class="number">1</span>); <span class="comment">// 获取总线钥匙</span></span><br><span class="line">        @bus<span class="variable">.cb</span>; <span class="comment">// 把信号驱动到总线上</span></span><br><span class="line">        bus<span class="variable">.cb</span><span class="variable">.addr</span> &lt;= t<span class="variable">.addr</span>;</span><br><span class="line">        ...</span><br><span class="line">        sem<span class="variable">.put</span>(<span class="number">1</span>); <span class="comment">// 处理完成时把钥匙返回</span></span><br><span class="line">    <span class="keyword">endtask</span></span><br><span class="line"><span class="keyword">endprogram</span></span><br></pre></td></tr></table></figure>
<hr>
<h4 id="mailbox信箱">mailbox信箱</h4>
<ul>
<li>线程之间如果传递信息，可以使用mailbox</li>
<li>mailbox和队列queue有相近之处</li>
<li>mailbox是一种对象，因此也需要使用new()来例化。例化时有一个可选的参数size来限定其存储的最大数量。如果size是0或者没有指定，则信箱是无限大的，可以容纳任意多的条目</li>
<li>使用put()可以把数据放入mailbox，使用get()可以从信箱移除数据</li>
<li>如果信箱为满，则put()会阻塞；如果信箱为空，则get()会阻塞</li>
<li>peek()可以获取对信箱里数据的拷贝而不移除它</li>
<li>线程之间的同步方法需要注意，哪些是阻塞方法，哪些是非阻塞方法，即哪些是立即返回的，而哪些可能需要等待时间的</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">program</span> <span class="keyword">automatic</span> bounded;</span><br><span class="line">    mailbox mbx;</span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        mbx = <span class="keyword">new</span>(<span class="number">1</span>); <span class="comment">// 容量为1</span></span><br><span class="line">        <span class="keyword">fork</span></span><br><span class="line">        <span class="comment">// Producer线程</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;<span class="number">4</span>; i++) <span class="keyword">begin</span></span><br><span class="line">                <span class="built_in">$display</span>(<span class="string">"Producer: before put(%0d)"</span>, i);</span><br><span class="line">                mbx<span class="variable">.put</span>(i);</span><br><span class="line">                <span class="built_in">$display</span>(<span class="string">"Producer: after put(%0d)"</span>, i);</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">      </span><br><span class="line">        <span class="comment">// Consumer线程</span></span><br><span class="line">            <span class="keyword">repeat</span>(<span class="number">4</span>) <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">int</span> j;</span><br><span class="line">                #<span class="number">1</span>ns mbx<span class="variable">.get</span>(j);</span><br><span class="line">                <span class="built_in">$display</span>(<span class="string">"Consumer: after get(%0d)"</span>, j);</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">join</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endprogram</span></span><br></pre></td></tr></table></figure>
<ul>
<li>mailbox在例化时，通过new(N)的方式可以使其变为定长（fixed length）容器。这样在负载到长度N以后，无法再对其写入。如果用new()的方式，则表示信箱容量不限大小</li>
<li>除了put()/get()/peek()这样的阻塞方法，用户也可以考虑使用try_put()/try_get()/try_peek()等非阻塞方法</li>
<li>如果要显式地限定mailbox中元素的类型，可以通过mailbox #(type = T)的方式来声明</li>
</ul>
<p>maibox与queue的异同</p>
<ul>
<li>maibox必须通过new()例化，而queue只需要声明</li>
<li>mailbox可以将不同的数据类型同时存储，不过这么做是不建议的；对于queue来讲，它内部存储的元素类型必须一致</li>
<li>maibox的存取方法put()和get()是阻塞方法，即使用它们时，方法不一定会立即返回，而queue所对应的存取方式，push_back()和pop_front()方法是非阻塞的，会立即返回。因此在使用queue取数时，需要额外填写wait(queue.size() &gt; 0)才可以在其后对非空的queue做取数的操作。此外也应该注意，如果要调用阻塞方法，那么只可以在task中调用，因为阻塞方法是耗时的；而调用非阻塞方法，例如queue的push_back()和pop_front()，则既可以在task又可以在function中调用</li>
<li>mailbox只能够用作FIFO，而queue除了按照FIFO使用，还有其它应用的方式例如LIFO（Last In First Out）。</li>
<li>对于mailbox变量的操作，在传递形式参数时，实际传递并拷贝的是mailbox的指针；而用queue实现类似功能时传递的形式参数应该声明为ref，因为如果采用默认的input方向，那么传递过程中发生的是数组的拷贝，以致于方法内部对queue的操作并不会影响外部的queue本身。因此在传递数组时，用户需要考虑到，对数组做的是引用还是拷贝，进而考虑端口声明的方向</li>
</ul>
<hr>
<h4 id="总结">总结</h4>
<p><em>用来做线程同步的选择也有多种。如果要在同步（事件）的同时，完成一些数据传输，那么更合适的是mailbox，因为它可以用来存储一些数据；而event和semaphore更偏向于小信息量的同步，即不包含更多的数据信息</em></p>
<ul>
<li>event：最小信息量的触发，即单一的通知功能。可以用来做事件的触发，也可以多个event组合起来用来做线程之间的同步</li>
<li>semaphore：共享资源的安全卫士。如果多线程间要对某一公共资源做访问，即可以使用这个要素</li>
<li>mailbox：精小的SV原生FIFO。在线程之间做数据通信或者内部数据缓存时可以考虑使用此元素</li>
</ul>
<hr>
<h2 id="随机约束">随机约束</h2>
<h3 id="随机化">随机化</h3>
<ul>
<li>随机的对象不只是一个数据，而是有联系的变量集。通常这些变量会被封装在一个数据类中，同时需要在类中声明数据之间的约束关系。因此约束之后要产生随机数据需要一个“求解器”，即在满足数据本身和数据之间约束关系时的随机数值解</li>
<li>随机化是为了产生更多可能的驱动，因此在软件世界class一侧的运用更多，所以我们倾向于将相关数据有机整理在一个类的同时，也用rand关键词来表明它们的随机属性</li>
<li>randc表示周期随机性，即所有可能的值都赋过值后随机值才可能重复</li>
<li>随机属性需要配合SV预定义的类随机函数std::randomize()使用。即只有通过声明rand变量，并且在后期通过对象调用randomize()函数才可以随机化变量</li>
<li>约束constraint也同随机变量一起在类中声明</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Packet;</span><br><span class="line">    <span class="comment">// 生命随机变量</span></span><br><span class="line">    <span class="keyword">rand</span> <span class="keyword">bit</span> [<span class="number">31</span>:<span class="number">0</span>] src, dst, data[<span class="number">8</span>];</span><br><span class="line">    <span class="keyword">randc</span> <span class="keyword">bit</span> [<span class="number">7</span>:<span class="number">0</span>] kind;</span><br><span class="line">    <span class="comment">// 约束src变量</span></span><br><span class="line">    <span class="keyword">constraint</span> c &#123;src &gt; <span class="number">10</span>;</span><br><span class="line">                  src &lt; <span class="number">15</span>;&#125;</span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line">Packet p;</span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    p = <span class="keyword">new</span>(); <span class="comment">// 创建packet对象</span></span><br><span class="line">    <span class="keyword">assert</span> (p<span class="variable">.randomize</span>()) <span class="keyword">else</span> </span><br><span class="line">        <span class="built_in">$fatal</span>(<span class="number">0</span>, <span class="string">"Packet::randomize failed"</span>);</span><br><span class="line">    transmit(p);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<ul>
<li>约束表达式的求解是由SV的约束求解器（constraint solver）完成的</li>
<li>求解器能够选择满足约束的值，这个值是由SV的PRNG（伪随机数发生器 Pseudo random number generator）从一个初始值（seed）产生。只要改变种子的值，就可以改变CRT的行为</li>
<li>SV标准定义了表达式的含义以及产生的合法值，但没有规定求解器计算约束的准确顺序。这即是说，不同仿真器对于同一个约束类和种子值求解出的数值可能是不相同的</li>
<li>什么可以被约束？SV只能随机化2值数据类型，但位可以是2值或4值。这即是说，无法随机化出X值和Z值，也无法随机化字符串</li>
</ul>
<hr>
<h3 id="权重分布">权重分布</h3>
<ul>
<li>关键词dist可以在约束中用来产生随机数值的权重分布，这样某些值的选取机会要比其他值更大一些</li>
<li>dist操作符带有一个值的列表以及相应的权重，中间用:=或:/分开。值或权重可以是常数或者变量</li>
<li>权重不用百分比表示，权重的和也不必是100</li>
<li>:=操作符表示值范围内的每一个值的权重是相同的，:/操作符表示权重要平均分到值范围内的每一个值</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rand</span> <span class="keyword">int</span> src, dst;</span><br><span class="line"><span class="keyword">constraint</span> c_dist &#123;</span><br><span class="line">    src <span class="keyword">dist</span> &#123;<span class="number">0</span>:=<span class="number">40</span>, [<span class="number">1</span>:<span class="number">3</span>]:=<span class="number">60</span>&#125;;</span><br><span class="line">    <span class="comment">// src = 0, weight = 40/220</span></span><br><span class="line">    <span class="comment">// src = 1, weight = 60/220</span></span><br><span class="line">    <span class="comment">// src = 2, weight = 60/220</span></span><br><span class="line">    <span class="comment">// src = 3, weight = 60/220</span></span><br><span class="line">    dst <span class="keyword">dist</span> &#123;<span class="number">0</span>:/<span class="number">40</span>, [<span class="number">1</span>:<span class="number">3</span>]:/<span class="number">60</span>&#125;;</span><br><span class="line">    <span class="comment">// dst = 0, weight = 40/100</span></span><br><span class="line">    <span class="comment">// dst = 1, weight = 20/100</span></span><br><span class="line">    <span class="comment">// dst = 2, weight = 20/100</span></span><br><span class="line">    <span class="comment">// dst = 3, weight = 20/100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="集合成员和inside运算符">集合成员和inside运算符</h3>
<ul>
<li>inside是常见的约束运算符，表示变量应该属于某一个值的集合，除非还存在其他约束，否则随机变量在集合里取值的概率是相等的。集合里也可以使用变量</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rand</span> <span class="keyword">int</span> c; <span class="comment">// 随机变量</span></span><br><span class="line"><span class="keyword">int</span> lo, hi; <span class="comment">// 作为上限和下限的非随机变量</span></span><br><span class="line"><span class="keyword">constraint</span> c_range &#123;</span><br><span class="line">    c <span class="keyword">inside</span> &#123;[lo:hi]&#125;; <span class="comment">// lo &lt;= c &amp;&amp; c &lt;= hi</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用“$”指定最大值和最小值</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rand</span> <span class="keyword">bit</span> [<span class="number">6</span>:<span class="number">0</span>] b; <span class="comment">// 0 &lt;= b &lt;= 127</span></span><br><span class="line"><span class="keyword">rand</span> <span class="keyword">bit</span> [<span class="number">5</span>:<span class="number">0</span>] e; <span class="comment">// 0 &lt;= e &lt;= 63</span></span><br><span class="line"><span class="keyword">constraint</span> c_range &#123;</span><br><span class="line">    b <span class="keyword">inside</span> &#123;[$:<span class="number">4</span>], [<span class="number">20</span>:$&#125;; <span class="comment">// 0 &lt;= b &lt;= 4 || 20 &lt;= b &lt;= 127</span></span><br><span class="line">    e <span class="keyword">inside</span> &#123;[$:<span class="number">4</span>], [<span class="number">20</span>:$&#125;; <span class="comment">// 0 &lt;= e &lt;= 4 || 20 &lt;= e &lt;= 63</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="条件约束">条件约束</h3>
<p><em>可以通过-&gt;或者if-else来让一个约束表达式在特定时刻有效</em></p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> BusOp;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">constraint</span> c_io &#123;</span><br><span class="line">        (io_space_mode) -&gt;</span><br><span class="line">        addr[<span class="number">31</span>] == <span class="number">1</span>’b1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> BusOp;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">constraint</span> c_len_rw &#123;</span><br><span class="line">        <span class="keyword">if</span> (op == READ)</span><br><span class="line">            len <span class="keyword">inside</span> &#123;[BYTE:LWRD]&#125;;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            len == LWRD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="双向约束">双向约束</h3>
<ul>
<li>约束块不像自上向下的程序性代码，它们是声明性的代码，是并行的，所有的约束表达式同时有效</li>
<li>同时，约束也是双向的，这表示它会同时计算所有的随机变量的约束。增加或删除任何一个变量的约束都会直接或间接影响所有相关的值的选取</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rand</span> <span class="keyword">logic</span> [<span class="number">15</span>:<span class="number">0</span>] r, s, t;</span><br><span class="line"><span class="keyword">constraint</span> c_bidir &#123;</span><br><span class="line">    r &lt; t;</span><br><span class="line">    s == r;</span><br><span class="line">    t &lt; <span class="number">30</span>;</span><br><span class="line">    s &gt; <span class="number">25</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:center">solution</th>
<th style="text-align:center">r</th>
<th style="text-align:center">s</th>
<th style="text-align:center">t</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">A</td>
<td style="text-align:center">26</td>
<td style="text-align:center">26</td>
<td style="text-align:center">27</td>
</tr>
<tr>
<td style="text-align:center">B</td>
<td style="text-align:center">26</td>
<td style="text-align:center">26</td>
<td style="text-align:center">28</td>
</tr>
<tr>
<td style="text-align:center">C</td>
<td style="text-align:center">26</td>
<td style="text-align:center">26</td>
<td style="text-align:center">29</td>
</tr>
<tr>
<td style="text-align:center">D</td>
<td style="text-align:center">27</td>
<td style="text-align:center">27</td>
<td style="text-align:center">28</td>
</tr>
<tr>
<td style="text-align:center">E</td>
<td style="text-align:center">27</td>
<td style="text-align:center">27</td>
<td style="text-align:center">29</td>
</tr>
<tr>
<td style="text-align:center">F</td>
<td style="text-align:center">28</td>
<td style="text-align:center">28</td>
<td style="text-align:center">29</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="约束块控制">约束块控制</h3>
<ul>
<li>一个类可以包含多个约束块。可以把不同约束块用于不同测试</li>
<li>一般情况下，各个约束块之间的约束内容是互相协调不违背的，因此通过随机函数产生随机数时可以找到合适的解</li>
<li>对于其它情况，例如根据不同需要，来选择使能哪些约束块，禁止哪些约束块的要求，可以使用内建的constraint_mode()函数打开或者关闭约束</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Packet;</span><br><span class="line">    <span class="keyword">rand</span> <span class="keyword">int</span> length;</span><br><span class="line">    <span class="keyword">constraint</span> c_short &#123;length <span class="keyword">inside</span></span><br><span class="line">                       &#123;[<span class="number">1</span>:<span class="number">32</span>]&#125;; &#125;</span><br><span class="line">    <span class="keyword">constraint</span> c_long &#123;length <span class="keyword">inside</span></span><br><span class="line">                      &#123;[<span class="number">1000</span>:<span class="number">1023</span>]&#125;; &#125;</span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line">Packet p;</span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    p = <span class="keyword">new</span>();</span><br><span class="line">    <span class="comment">// 通过关闭short约束创建一个long packet</span></span><br><span class="line">    p<span class="variable">.c_short</span><span class="variable">.constraint_mode</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">assert</span> (p<span class="variable">.randomize</span>());</span><br><span class="line">    transmit(p);</span><br><span class="line">    <span class="comment">// 通过先关闭所有约束再打开short约束创建一个short packet</span></span><br><span class="line">    p<span class="variable">.constraint_mode</span>(<span class="number">0</span>);</span><br><span class="line">    p<span class="variable">.c_short</span><span class="variable">.constraint_mode</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">assert</span> (p<span class="variable">.randomize</span>());</span><br><span class="line">    transmit(p);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="内嵌约束">内嵌约束</h3>
<ul>
<li>伴随着复杂的约束，它们之间会相互作用，最终产生难以预测的结果。用来使能和禁止这些约束的代码也会增加测试的复杂性</li>
<li>经常增加或修改类例的约束也可能会影响整个团队的工作，这需要考虑类的开放封闭原则（OCP）</li>
<li>SV允许使用randomize() with来增加额外的约束，这和在类里增加约束是等效的，但同时要注意类内部约束和外部约束之间应该是协调的，如果出现互相违背的情况，那么随机数值求解会失败</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Transaction;</span><br><span class="line">    <span class="keyword">rand</span> <span class="keyword">bit</span> [<span class="number">31</span>:<span class="number">0</span>] addr, data;</span><br><span class="line">    <span class="keyword">constraint</span> c1 &#123;</span><br><span class="line">        <span class="keyword">soft</span> addr <span class="keyword">inside</span></span><br><span class="line">                  &#123;[<span class="number">0</span>:<span class="number">100</span>],[<span class="number">1000</span>:<span class="number">2000</span>]&#125;;&#125;</span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line">Transaction t;</span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    t = <span class="keyword">new</span>();</span><br><span class="line">    <span class="comment">// addr取值50-100和1000-1500, data &lt; 10</span></span><br><span class="line">    <span class="keyword">assert</span>(t<span class="variable">.randomize</span>() <span class="keyword">with</span> </span><br><span class="line">        &#123;addr &gt;= <span class="number">50</span>; addr &lt;= <span class="number">1500</span>;</span><br><span class="line">         data &lt; <span class="number">10</span>;&#125;);</span><br><span class="line">    driveBus(t);</span><br><span class="line">    <span class="comment">// 约束addr为定值, data &gt; 10</span></span><br><span class="line">    <span class="keyword">assert</span>(t<span class="variable">.randomize</span>() <span class="keyword">with</span> </span><br><span class="line">        &#123;addr == <span class="number">2000</span>; data &gt; <span class="number">10</span>;&#125;);</span><br><span class="line">    driveBus(t);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="随机函数">随机函数</h3>
<ul>
<li>有时需要在调用randomize()之前或之后立即执行一些操作，例如在随机前设置类例的一些非随机变量（上下限、条件值、权重），或者在随机化之后需要计算随机数据的误差、分析和记录随机数据等</li>
<li>SV提供了两个预定义的void类型函数pre_randomize()和post_randomize()函数。用户可以类中定义这两个函数，分别在其中定义随机化前的行为和随机化后的行为</li>
<li>如果某个类中定义了pre_randomize()或者post_randomize()函数，那么对象在执行了randomize()之前或者之后会分别执行这两个函数。所以，pre_randomize()和post_randomize()可以看做是randomize()函数的回调函数（callback function）</li>
</ul>
<p><em>SV提供了一些常用的系统随机函数。这些随机函数可以直接调用来返回随机数值</em></p>
<ul>
<li>$random() 平均分布，返回32位有符号随机数</li>
<li>$urandom()平均分布，返回32位无符号随机数</li>
<li>$urandom_range() 在指定范围内的平均分布</li>
</ul>
<p><em>随机化个别变量</em></p>
<ul>
<li>在调用randomize()时可以传递变量的一个子集，这样只会随机化类里的几个变量</li>
<li>只有参数列表里的变量才会被随机化，其它变量会被当做状态变量而不会被随机化</li>
<li>所有的约束仍然保持有效</li>
<li>该种应用针对的是类里所有被指定或者没有被指定rand的变量都可以作为randomize()的参数而被随机化</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Rising;</span><br><span class="line">    <span class="keyword">byte</span> low; <span class="comment">// Not random variable</span></span><br><span class="line">    <span class="keyword">rand</span> <span class="keyword">byte</span> med, hi; <span class="comment">// Random variable</span></span><br><span class="line">    <span class="keyword">constraint</span> up</span><br><span class="line">        &#123; low &lt; med; med &lt; hi; &#125; </span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    Rising r;</span><br><span class="line">    r = <span class="keyword">new</span>();</span><br><span class="line">    r<span class="variable">.randomize</span>(); <span class="comment">// 随机化hi，但不改变low</span></span><br><span class="line">    r<span class="variable">.randomize</span>(med); <span class="comment">// 只随机化med</span></span><br><span class="line">    r<span class="variable">.randomize</span>(low); <span class="comment">// 只随机化low</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="数组约束">数组约束</h3>
<ul>
<li>在约束随机标量的同时，我们还可以对随机化数组进行约束</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> dyn_size;</span><br><span class="line">    <span class="keyword">rand</span> <span class="keyword">logic</span> [<span class="number">31</span>:<span class="number">0</span>] d[];</span><br><span class="line">    <span class="keyword">constraint</span> d_size &#123;d<span class="variable">.size</span>() <span class="keyword">inside</span> &#123;[<span class="number">1</span>:<span class="number">10</span>]&#125;; &#125;</span><br><span class="line"><span class="keyword">endclass</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>多数情况下，数组的大小应该给定范围，防止生成过大体积的数组或者空数组</p>
</li>
<li>
<p>此外还可以在约束中结合数组的其它方法sum()，product()，and()，or()和xor()等</p>
</li>
<li>
<p>SV可以利用foreach对数组的每一个元素进行约束，和直接写出对固定大小数组的每一个元素的约束相比，foreach要更简洁</p>
</li>
<li>
<p>针对动态数组，foreach更适合于对非固定大小数组中每个元素的约束</p>
</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> good_sum5;</span><br><span class="line">    <span class="keyword">rand</span> uint len[];</span><br><span class="line">    <span class="keyword">constraint</span> c_len &#123;</span><br><span class="line">        <span class="keyword">foreach</span> (len[i]) </span><br><span class="line">            len[i] <span class="keyword">inside</span> &#123;[<span class="number">1</span>:<span class="number">255</span>]&#125;;</span><br><span class="line">        len<span class="variable">.sum</span>() &lt; <span class="number">1024</span>;</span><br><span class="line">        len<span class="variable">.size</span>() <span class="keyword">inside</span> &#123;[<span class="number">1</span>:<span class="number">8</span>]&#125;;&#125;</span><br><span class="line"><span class="keyword">endclass</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="产生唯一值元素的数组">产生唯一值元素的数组</h3>
<ul>
<li>如果想要产生一个随机数组，它的每一个元素的值都是唯一的。如果使用randc数组，那么数组中的每一个元素只会独立地随机化，并不会按照我们的本意使得数组中的元素值是唯一的</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> UniqueSlow;</span><br><span class="line">    <span class="keyword">rand</span> <span class="keyword">bit</span> [<span class="number">7</span>:<span class="number">0</span>] ua[<span class="number">64</span>];</span><br><span class="line">    <span class="keyword">constraint</span> c &#123;</span><br><span class="line">        <span class="keyword">foreach</span> (ua[i]) <span class="comment">// 对数组中的每一个元素操作</span></span><br><span class="line">            <span class="keyword">foreach</span> (ua[j])</span><br><span class="line">			    <span class="keyword">if</span> (i != j) <span class="comment">// 除了元素自己</span></span><br><span class="line">			        ua[i] != ua[j]; <span class="comment">// 和其它元素比较</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">endclass</span></span><br></pre></td></tr></table></figure>
<ul>
<li>也可以利用randc变量来辅助生成唯一元素值的数组</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> randc8;</span><br><span class="line">    <span class="keyword">randc</span> <span class="keyword">bit</span> [<span class="number">7</span>:<span class="number">0</span>] val;</span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> LittleUniqueArray;</span><br><span class="line">    <span class="keyword">bit</span> [<span class="number">7</span>:<span class="number">0</span>] ua [<span class="number">64</span>]; <span class="comment">// 唯一值元素的数组</span></span><br><span class="line">    <span class="keyword">function</span> <span class="keyword">void</span> pre_randomize();</span><br><span class="line">        randc8 rc8;</span><br><span class="line">        rc8 = <span class="keyword">new</span>();</span><br><span class="line">        <span class="keyword">foreach</span> (ua[i]) <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">assert</span>(rc8<span class="variable">.randomize</span>());</span><br><span class="line">            ua[i] = rc8<span class="variable">.val</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="随机化句柄数组">随机化句柄数组</h3>
<ul>
<li>随机句柄数组的功能是在调用其所在类的随机函数时，随机函数会随机化数组中的每一个句柄所指向的对象。因此随机句柄数组的声明一定要添加rand来表示其随机化的属性，同时在调用随机函数前要保证句柄数组中的每一个句柄元素都是非悬空的，这需要在随机化之前为每一个元素句柄构建对象</li>
<li>如果要产生多个随机对象，那么可能需要建立随机句柄数组。和整数数组不同，需要在随机化前分配所有的元素，因为随机求解器不会创建对象。使用动态数组可以按照需要分配最大数量的元素，然后再使用约束减小数组的大小。在随机化时，动态句柄数组的大小可以保持不变或减小，但不能增加</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">parameter</span> MAX_SIZE = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">class</span> RandStuff;</span><br><span class="line">    <span class="keyword">bit</span>[<span class="number">1</span>:<span class="number">0</span>] value = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> RandArray;</span><br><span class="line">    <span class="keyword">rand</span> RandStuff array[]; </span><br><span class="line">    <span class="keyword">constraint</span> c &#123;</span><br><span class="line">        array<span class="variable">.size</span>() <span class="keyword">inside</span> &#123;[<span class="number">1</span>:MAX_SIZE]&#125;;&#125;</span><br><span class="line">    <span class="keyword">function</span> <span class="keyword">new</span>();</span><br><span class="line">    <span class="comment">//分配最大容量</span></span><br><span class="line">        array = <span class="keyword">new</span>[MAX_SIZE];  </span><br><span class="line">        <span class="keyword">foreach</span> (array[i])</span><br><span class="line">        array[i] = <span class="keyword">new</span>();</span><br><span class="line">    <span class="keyword">endfunction</span>;</span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line">RandArray ra;</span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="comment">// 构造数组和所有对象</span></span><br><span class="line">    ra = <span class="keyword">new</span>(); </span><br><span class="line">    <span class="comment">// 随机化数组，但可能会减小数组</span></span><br><span class="line">    <span class="keyword">assert</span>(ra<span class="variable">.randomize</span>());</span><br><span class="line">    <span class="keyword">foreach</span> (ra<span class="variable">.array</span>[i])</span><br><span class="line">        <span class="built_in">$display</span>(ra<span class="variable">.array</span>[i]<span class="variable">.value</span>);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="随机序列">随机序列</h3>
<ul>
<li>产生事务序列的另一个方法是使用SV的randsequence结构。这对于随机安排组织原子（atomic）测试序列很有帮助</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">15</span>; i++) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">randsequence</span> (stream)</span><br><span class="line">            stream : cfg_read := <span class="number">1</span> |</span><br><span class="line">                      io_read := <span class="number">2</span> |</span><br><span class="line">				     mem_read := <span class="number">5</span>;</span><br><span class="line">            cfg_read : &#123; cfg_read_task; &#125; |</span><br><span class="line">                       &#123; cfg_read_task; &#125; cfg_read;</span><br><span class="line">            mem_read : &#123; mem_read_task; &#125; |</span><br><span class="line">                       &#123; mem_read_task; &#125; mem_read;</span><br><span class="line">            io_read : &#123; io_read_task; &#125; |</span><br><span class="line">                      &#123; io_read_task; &#125; io_read;</span><br><span class="line">        <span class="keyword">endsequence</span></span><br><span class="line">    <span class="keyword">end</span> <span class="comment">// for</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<ul>
<li>也可以使用randcase来建立随机决策树，但它带来的问题是没有变量可供追踪调试</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">randcase</span></span><br><span class="line">        <span class="number">1</span>: len = $urandom_range(<span class="number">0</span>, <span class="number">2</span>); <span class="comment">// 10%: 0, 1, or 2</span></span><br><span class="line">        <span class="number">8</span>: len = $urandom_range(<span class="number">3</span>, <span class="number">5</span>); <span class="comment">// 80%: 3, 4, or 5</span></span><br><span class="line">        <span class="number">1</span>: len = $urandom_range(<span class="number">6</span>, <span class="number">7</span>); <span class="comment">// 10%: 6 or 7</span></span><br><span class="line">    <span class="keyword">endcase</span></span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">"len=%0d"</span>, len);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<ul>
<li>randsequence和randcase是针对轻量级的随机控制的应用。可以通过定义随机类取代上述随机控制的功能，并且由于类的继承性使得在后期维护代码时更加方便</li>
<li>randsequence的相关功能在协调激励组件和测试用例时，可能会用到</li>
<li>randcase则对应着随机约束中的dist权重约束+if-else条件约束的组合</li>
</ul>
<hr>
<h2 id="覆盖率">覆盖率</h2>
<p>衡量验证完备性的指标</p>
<h3 id="覆盖率反馈回路">覆盖率反馈回路</h3>
<ul>
<li>可以使用一个反馈回路来分析覆盖率的结果，并决定采取哪种行动来达到100%的覆盖率</li>
<li>首先选择使用更多的种子来运行现有的测试程序</li>
<li>当大量种子依然对于覆盖率增长没有帮助时，需要建立新的约束</li>
<li>只有在确实需要的时候才会求助于创建定向测试。</li>
</ul>
<p><img src="http://p5mgt22l9.bkt.clouddn.com/%E8%A6%86%E7%9B%96%E7%8E%87%E5%8F%8D%E9%A6%88%E5%9B%9E%E8%B7%AF.png" alt="此处输入图片的描述"></p>
<hr>
<h3 id="代码覆盖率">代码覆盖率</h3>
<ul>
<li>不添加任何额外的HDL代码，工具会通过分析源代码和增加隐藏代码来自动完成代码覆盖率的统计。当运行完所有测试，工具便会创建相应的数据库</li>
<li>包括line，branch，condition，fsm，toggle覆盖率等</li>
<li>代码覆盖率最终的结果用于衡量执行了设计中的多少代码</li>
<li>关注点应该放在设计代码的分析上，而不是测试平台</li>
<li>未经测试的设计代码里可能隐藏硬件漏洞，也可能仅仅就是冗余的代码</li>
<li>代码覆盖率衡量的是测试对于硬件设计描述的“实现”究竟测试得有多彻底，而非针对验证计划</li>
<li>代码覆盖率达到了100%，并不意味着验证的工作已经完成，但代码覆盖率100%是验证工作完备性的必要条件</li>
</ul>
<hr>
<h3 id="功能覆盖率">功能覆盖率</h3>
<ul>
<li>验证的目的就是确保设计在实际环境中的行为正确</li>
<li>功能描述文档详细说明了设计应该如何运行，而验证计划则列出了相应的功能应该如何激励、验证和测量</li>
<li>当你收集测量数据希望找出那些功能已经被覆盖时，你其实就是在计算“设计”的覆盖率</li>
<li>功能覆盖率是和功能设计意图紧密相连的，有时也被称为“描述覆盖率”，而代码覆盖率则是衡量设计的实现情况</li>
<li>某个功能在设计中可以被遗漏，代码覆盖率不能发现这个错误，但是功能覆盖率可以</li>
</ul>
<ul>
<li>每一次仿真都会产生一个带有覆盖率信息的数据库，记录随机游走的轨迹。把这些信息全部合并在一起就可以得到功能覆盖率，从而衡量整体的进展程度。</li>
<li>通过分析覆盖率数据可以决定如何修改回归测试集。如果覆盖率在稳步增长，那么添加新种子或者加长测试实际即可。如果覆盖率增速放缓，那么需要添加额外的约束来产生更多“有意思”的激励。如果覆盖率停止增长，然而设计某些测试点没有被覆盖到，那么就需要创建新的测试了。如果覆盖率为100%但依然有新的设计漏洞，那么覆盖率可能没有覆盖到设计中的某些设计功能区域</li>
</ul>
<hr>
<h3 id="断言覆盖率">断言覆盖率</h3>
<ul>
<li>断言是用于一次性地或在一段时间对一个或者多个设计信号在逻辑或者时序上的声明性代码</li>
<li>断言可以跟随设计和测试平台一起仿真，也可以被形式验证工具所证实</li>
<li>可以使用SV的程序性代码编写等效性检查，但使用SVA（SV断言）来表达会更容易</li>
<li>断言最常用于查找错误，例如两个信号是否应该互斥，或者请求与许可信号之间的时序等</li>
<li>一旦检测到问题，仿真就可以立即停止</li>
<li>有些断言可以用于查找感兴趣的信号值或者设计状态， 可以使用cover property来测量这些关心的信号值或者状态是否发生。在仿真结束时，工具可以自动生成断言覆盖率数据。断言覆盖率数据以及其它覆盖率数据都会被集成在同一个覆盖率数据库中，验证人员可以对其展开分析</li>
</ul>
<hr>
<h3 id="验证的策略和完备性">验证的策略和完备性</h3>
<h4 id="功能覆盖率的策略">功能覆盖率的策略</h4>
<ul>
<li>收集信息而非数据。一旦关注的地方着眼于感兴趣的状态，而不是具体数值，那么这对于如何定义功能覆盖率，以及如何收集信息会减轻很大的负担</li>
<li>设计信号如果数量范围太大，应该拆分为多个小范围再加上边界情况</li>
<li>在使能覆盖率收集时，这一特性会很大程度的降低仿真性能。由于收集功能覆盖率数据的开销很大，所以应该只测量会用来分析并且改进测试的那部分数据</li>
<li>同时也需要设定合理的覆盖率采样的事件，一方面提升采样效率，一方面也可以降低收集覆盖率的开销</li>
</ul>
<hr>
<h4 id="验证的完备性">验证的完备性</h4>
<ul>
<li>完备的覆盖率测量结果和漏洞增长曲线，可以帮助确认设计是否被完整地验证过</li>
<li>如果功能覆盖率低但代码覆盖率高，这说明验证计划不完整，测试没有执行设计的所有代码</li>
<li>如果代码覆盖率高但功能覆盖率低，这说明即使测试平台很好地执行了设计的所有代码，但是测试还是没有把设计定位到所有感兴趣的状态上</li>
<li>验证人员的目标是同时驱动高的代码覆盖率和功能覆盖率</li>
</ul>
<p><img src="http://p5mgt22l9.bkt.clouddn.com/%E9%AA%8C%E8%AF%81%E7%9A%84%E5%AE%8C%E5%A4%87%E6%80%A7.png" alt="此处输入图片的描述"></p>
<hr>
<h3 id="covergroup">covergroup</h3>
<ul>
<li>覆盖组（covergroup）与类相似，一次定义后便可以多次实例化</li>
<li>covergroup可以包含一个或者多个coverpoint，且全都在同一时间采集</li>
<li>covergroup可以定义在类中，也可以定义在interface或者module中</li>
<li>covergroup可以采样任何可见的变量，例如程序变量、接口信号或者设计端口</li>
<li>一个类里可以包含多个covergroup</li>
<li>当拥有多个独立的covergroup时，每个covergroup可以根据需要自行使能或者禁止</li>
<li>每个covergroup可以定义单独的触发采样事件，允许从多个源头收集数据</li>
<li>covergroup必须被例化才可以用来收集数据</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Transactor;</span><br><span class="line">    Transaction tr;</span><br><span class="line">    mailbox mbx_in;</span><br><span class="line">    <span class="keyword">covergroup</span> CovPort;</span><br><span class="line">        <span class="keyword">coverpoint</span> tr<span class="variable">.port</span>;</span><br><span class="line">    <span class="keyword">endgroup</span></span><br><span class="line">    <span class="keyword">function</span> <span class="keyword">new</span>(mailbox mbx_in);</span><br><span class="line">        CovPort = <span class="keyword">new</span>(); </span><br><span class="line">        <span class="keyword">this</span><span class="variable">.mbx_in</span> = mbx_in;</span><br><span class="line">    <span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">task</span> main;</span><br><span class="line">        <span class="keyword">forever</span> <span class="keyword">begin</span></span><br><span class="line">            tr = mbx_in<span class="variable">.get</span>; </span><br><span class="line">            ifc<span class="variable">.cb</span><span class="variable">.port</span> &lt;= tr<span class="variable">.port</span>;   </span><br><span class="line">            ifc<span class="variable">.cb</span><span class="variable">.data</span> &lt;= tr<span class="variable">.data</span>;</span><br><span class="line">            CovPort<span class="variable">.sample</span>(); </span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">endtask</span></span><br><span class="line"><span class="keyword">endclass</span></span><br></pre></td></tr></table></figure>
<ul>
<li>covergroup由采样的数据和数据被采样的事件构成,当这两个条件都准备好以后，测试平台便会触发covergroup,这个过程可以通过直接使用sample()函数完成，也可以在covergroup中采样阻塞表达式或者使用wait或@实现在信号或事件上的阻塞</li>
<li>如果希望在代码中显式地触发covergroup采样，或者不存在采样时刻的信号或事件，又或者一个covergroup被例化为多个实例需要单独触发，那么可以使用sample()方法</li>
<li>如果想借助已有的事件或者信号触发covergroup，可以在covergroup声明中使用阻塞语句</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">event</span> trans_ready;</span><br><span class="line"><span class="comment">//与直接调用sample()相比，使用事件触发的好处在于能够借助已有的事件</span></span><br><span class="line"><span class="keyword">covergroup</span> CovPort @(trans_ready);</span><br><span class="line">    <span class="keyword">coverpoint</span> ifc<span class="variable">.cb</span><span class="variable">.port</span>; </span><br><span class="line"><span class="keyword">endgroup</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="数据采样">数据采样</h3>
<ul>
<li>当在coverpoint指定采样一个变量或表达式时，SV会创建很多的“仓（bin）”来记录每个数值被捕捉到的次数，这些bin是衡量功能覆盖率的基本单位</li>
<li>covergroup中可以定义多个coverpoint，coverpoint中可以自定义多个cover bin或者SV帮助自动定义多个cover bin</li>
<li>每次covergroup采样，SV都会在一个或者多个cover bin中留下标记，用来记录采样时变量的数值和匹配的cover bin</li>
<li>在仿真之后，可以使用分析工具读取这些数据库来生成覆盖率报告，包含了各部分和总体的覆盖率</li>
</ul>
<hr>
<h4 id="coverpoint和bin">coverpoint和bin</h4>
<ul>
<li>为了计算一个coverpoint上的覆盖率，首先需要确定可能数值的个数，这也被称为域</li>
<li>覆盖率就是采样值的数目除以bin的数目。例如一个3比特变量的域是0:7，正常情况下会自动分配8个bin。如果仿真过程中有7个值被采样到，那么最终该coverpoint的覆盖率是7/8</li>
<li>所有的coverpoint的覆盖率最终构成一个covergroup的覆盖率，所有的covergroup的覆盖率构成了整体的功能覆盖率</li>
</ul>
<hr>
<h4 id="bin的创建和应用">bin的创建和应用</h4>
<ul>
<li>SV会默认为某个coverpoint创建bin，用户也可以自己定义bin的采样域</li>
<li>如果采样变量的域范围过大而又没有指定bin，那么系统会默认分配64个bin，将值域范围平均分配给这64个bin</li>
<li>用户可以通过covergroup的选项auto_bin_max来指定自动创建bin的最大数目</li>
<li>实际操作中，自动创建bin的方法不实用，建议用户自行定义bin，或者减小auto_bin_max的数值</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">covergroup</span> CovPort;</span><br><span class="line">    options<span class="variable">.auto_bin_max</span> = <span class="number">8</span>; <span class="comment">// 所有coverpoint auto_bin数量=8</span></span><br><span class="line">    <span class="keyword">coverpoint</span> tr<span class="variable">.port</span> &#123; options<span class="variable">.auto_bin_max</span> = <span class="number">2</span>; &#125; <span class="comment">// 特定coverpoint auto_bin数量=2</span></span><br><span class="line"><span class="keyword">endgroup</span></span><br></pre></td></tr></table></figure>
<ul>
<li>注意coverpoint定义使用{}而不是begin...end。大括号的结尾没有带分号，这和end一样</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">covergroup</span> CovKind;</span><br><span class="line">    <span class="keyword">coverpoint</span> tr<span class="variable">.kind</span> &#123;</span><br><span class="line">        <span class="keyword">bins</span> zero = &#123;<span class="number">0</span>&#125;; <span class="comment">// 1个仓代表kind==0</span></span><br><span class="line">        <span class="keyword">bins</span> lo = &#123;[<span class="number">1</span>:<span class="number">3</span>], <span class="number">5</span>&#125;; <span class="comment">// 1个仓代表1:3和5</span></span><br><span class="line">        <span class="keyword">bins</span> hi[] = &#123;[<span class="number">8</span>:$]&#125;; <span class="comment">// 8个独立的仓代表8:15</span></span><br><span class="line">        <span class="keyword">bins</span> misc = <span class="keyword">default</span>; <span class="comment">// 1个仓代表剩余的所有值</span></span><br><span class="line">    &#125; <span class="comment">// 没有分号</span></span><br><span class="line"><span class="keyword">endgroup</span></span><br></pre></td></tr></table></figure>
<hr>
<h4 id="条件覆盖率">条件覆盖率</h4>
<ul>
<li>可以使用关键词iff给coverpoint添加条件</li>
<li>这种做法常用于在复位期间关闭覆盖以忽略不合理的条件触发</li>
<li>也可以使用start和stop函数来控制covergroup各个独立实例</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">covergroup</span> CoverPort;</span><br><span class="line">    <span class="keyword">coverpoint</span> port <span class="keyword">iff</span> (!bus_if<span class="variable">.reset</span>);</span><br><span class="line"><span class="keyword">endgroup</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    CoverPort ck = <span class="keyword">new</span>(); </span><br><span class="line">    #<span class="number">1</span>ns；</span><br><span class="line">    ck<span class="variable">.stop</span>();</span><br><span class="line">    bus_if<span class="variable">.reset</span> = <span class="number">1</span>;</span><br><span class="line">    #<span class="number">100</span>ns bus_if<span class="variable">.reset</span> = <span class="number">0</span>;   </span><br><span class="line">    ck<span class="variable">.start</span>();</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<hr>
<h4 id="翻转覆盖率">翻转覆盖率</h4>
<ul>
<li>coverpoint也可以用来记录变量从A值到B值的跳转情况</li>
<li>还可以确定任何长度的翻转次数</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">covergroup</span> CoverPort;</span><br><span class="line">    <span class="keyword">coverpoint</span> port &#123;</span><br><span class="line">        <span class="keyword">bins</span> t1 = (<span class="number">0</span> =&gt; <span class="number">1</span>), (<span class="number">0</span> =&gt; <span class="number">2</span>), (<span class="number">0</span> =&gt; <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">endgroup</span></span><br></pre></td></tr></table></figure>
<hr>
<h4 id="wildcard覆盖率">wildcard覆盖率</h4>
<ul>
<li>可以使用关键字wildcard来创建多个状态或者翻转</li>
<li>在表达式中，任何X,Z或者?都会被当成0或1的通配符</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bit</span> [<span class="number">2</span>:<span class="number">0</span>] port;</span><br><span class="line"><span class="keyword">covergroup</span> CoverPort;</span><br><span class="line">    <span class="keyword">coverpoint</span> port &#123;</span><br><span class="line">        <span class="keyword">wildcard</span> <span class="keyword">bins</span> even = &#123;<span class="number">3</span>’b??<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">wildcard</span> <span class="keyword">bins</span> odd = &#123;<span class="number">3</span>’b??<span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">endgroup</span></span><br></pre></td></tr></table></figure>
<hr>
<h4 id="忽略的bin">忽略的bin</h4>
<ul>
<li>在某些coverpoint可能始终无法得到全部的域值</li>
<li>对于那些不计算功能的域值可以使用ignore_bins来排除，最终它们并不会计入coverpoint的覆盖率</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bit</span> [<span class="number">2</span>:<span class="number">0</span>] low_ports_0_5; <span class="comment">// 只使用数值0-5</span></span><br><span class="line"><span class="keyword">covergroup</span> CoverPort;</span><br><span class="line">    <span class="keyword">coverpoint</span> low_ports_0_5 &#123;</span><br><span class="line">        <span class="keyword">ignore_bins</span> hi = &#123;[<span class="number">6</span>,<span class="number">7</span>]&#125;; <span class="comment">// 忽略数值6-7</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">endgroup</span></span><br></pre></td></tr></table></figure>
<hr>
<h4 id="非法的bin">非法的bin</h4>
<ul>
<li>有些采样值不仅应该被忽略，而且如果出现还应该报错</li>
<li>这种情况可以在测试平台中监测，也可以使用illegal_bins对特定的bin进行标示</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bit</span> [<span class="number">2</span>:<span class="number">0</span>] low_ports_0_5; <span class="comment">// 只是用数值0-5</span></span><br><span class="line"><span class="keyword">covergroup</span> CoverPort;</span><br><span class="line">    <span class="keyword">coverpoint</span> low_ports_0_5 &#123;</span><br><span class="line">        <span class="keyword">illegal_bins</span> hi = &#123;[<span class="number">6</span>,<span class="number">7</span>]&#125;; <span class="comment">// 如果出现6-7便报错</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">endgroup</span></span><br></pre></td></tr></table></figure>
<hr>
<h4 id="交叉覆盖率">交叉覆盖率</h4>
<ul>
<li>coverpoint是记录单个变量或者表达式的观测值</li>
<li>如果想记录在某一时刻，多个变量之间值的组合情况，需要使用交叉（cross）覆盖率</li>
<li>cross语句只允许带coverpoint或者简单的变量名</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Transaction;</span><br><span class="line">    <span class="keyword">rand</span> <span class="keyword">bit</span> [<span class="number">3</span>:<span class="number">0</span>] kind;</span><br><span class="line">    <span class="keyword">rand</span> <span class="keyword">bit</span> [<span class="number">2</span>:<span class="number">0</span>] port;</span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line">Transaction tr;</span><br><span class="line"><span class="keyword">covergroup</span> CovPort;</span><br><span class="line">    kind: <span class="keyword">coverpoint</span> tr<span class="variable">.kind</span>; </span><br><span class="line">    port: <span class="keyword">coverpoint</span> tr<span class="variable">.port</span>; </span><br><span class="line">    <span class="keyword">cross</span> kind, port; </span><br><span class="line"><span class="keyword">endgroup</span></span><br></pre></td></tr></table></figure>
<hr>
<h4 id="排除部分cross-bin">排除部分cross bin</h4>
<ul>
<li>通过使用ignore_bins、binsof和intersect分别指定coverpoint和值域，这样可以清除很多不关心的cross bin</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">covergroup</span> Covport;</span><br><span class="line">    port: <span class="keyword">coverpoint</span> tr<span class="variable">.port</span> &#123;</span><br><span class="line">        <span class="keyword">bins</span> port[] = &#123;[<span class="number">0</span>:$]&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    kind: <span class="keyword">coverpoint</span> tr<span class="variable">.kind</span> &#123;</span><br><span class="line">        <span class="keyword">bins</span> zero = &#123;<span class="number">0</span>&#125;; </span><br><span class="line">        <span class="keyword">bins</span> lo = &#123;[<span class="number">1</span>:<span class="number">3</span>]&#125;; </span><br><span class="line">        <span class="keyword">bins</span> hi[] = &#123;[<span class="number">8</span>:$]&#125;; </span><br><span class="line">        <span class="keyword">bins</span> misc = <span class="keyword">default</span>; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">cross</span> kind, port &#123;</span><br><span class="line">        <span class="keyword">ignore_bins</span> hi = <span class="keyword">binsof</span>(port) <span class="keyword">intersect</span> &#123;<span class="number">7</span>&#125;;</span><br><span class="line">        <span class="keyword">ignore_bins</span> md = <span class="keyword">binsof</span>(port) <span class="keyword">intersect</span> &#123;<span class="number">0</span>&#125; &amp;&amp;</span><br><span class="line">        <span class="keyword">binsof</span>(kind) <span class="keyword">intersect</span> &#123;[<span class="number">9</span>:<span class="number">11</span>]&#125;;</span><br><span class="line">        <span class="keyword">ignore_bins</span> lo = <span class="keyword">binsof</span>(kind<span class="variable">.lo</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">endgroup</span></span><br></pre></td></tr></table></figure>
<hr>
<h4 id="精细的交叉覆盖率指定">精细的交叉覆盖率指定</h4>
<ul>
<li>随着cross覆盖率越来越精细，可能需要花费不少的时间来指定哪些bin应该被使用或者被忽略</li>
<li>更适合的方式是不使用自动分配的cross bin，而自己声明感兴趣的cross bin</li>
</ul>
<p>假如有两个随机变量a和b，它们带着三种感兴趣的状态，{a==0,b==0}、{a==1、b==0}和{b==1}</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Transaction;</span><br><span class="line">    <span class="keyword">rand</span> <span class="keyword">bit</span> a, b;</span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">covergroup</span> CrossBinNames;</span><br><span class="line">    a: <span class="keyword">coverpoint</span> tr<span class="variable">.a</span></span><br><span class="line">        &#123; <span class="keyword">bins</span> a0 = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">          <span class="keyword">bins</span> a1 = &#123;<span class="number">1</span>&#125;;</span><br><span class="line">          option<span class="variable">.weight</span>=<span class="number">0</span>;&#125; <span class="comment">// 不计算覆盖率</span></span><br><span class="line">    b: <span class="keyword">coverpoint</span> tr<span class="variable">.b</span></span><br><span class="line">        &#123; <span class="keyword">bins</span> b0 = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">          <span class="keyword">bins</span> b1 = &#123;<span class="number">1</span>&#125;;</span><br><span class="line">          option<span class="variable">.weight</span>=<span class="number">0</span>;&#125; <span class="comment">// 不计算覆盖率</span></span><br><span class="line">    ab: <span class="keyword">cross</span> a, b</span><br><span class="line">        &#123; <span class="keyword">bins</span> a0b0 = <span class="keyword">binsof</span>(a<span class="variable">.a0</span>) &amp;&amp; <span class="keyword">binsof</span>(b<span class="variable">.b0</span>);</span><br><span class="line">          <span class="keyword">bins</span> a1b0 = <span class="keyword">binsof</span>(a<span class="variable">.a1</span>) &amp;&amp; <span class="keyword">binsof</span>(b<span class="variable">.b0</span>);</span><br><span class="line">          <span class="keyword">bins</span> b1 = <span class="keyword">binsof</span>(b<span class="variable">.b1</span>); &#125;</span><br><span class="line"><span class="keyword">endgroup</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">covergroup</span> CrossBinsofIntersect;</span><br><span class="line">    a: <span class="keyword">coverpoint</span> tr<span class="variable">.a</span></span><br><span class="line">        &#123; option<span class="variable">.weight</span>=<span class="number">0</span>; &#125; <span class="comment">// 不计算该coverpoint</span></span><br><span class="line">    b: <span class="keyword">coverpoint</span> tr<span class="variable">.b</span></span><br><span class="line">        &#123; option<span class="variable">.weight</span>=<span class="number">0</span>; &#125; <span class="comment">// 不计算该coverpoint</span></span><br><span class="line">    ab: <span class="keyword">cross</span> a, b</span><br><span class="line">        &#123; <span class="keyword">bins</span> a0b0 = <span class="keyword">binsof</span>(a) <span class="keyword">intersect</span> &#123;<span class="number">0</span>&#125; &amp;&amp; <span class="keyword">binsof</span>(b) <span class="keyword">intersect</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">          <span class="keyword">bins</span> a1b0 = <span class="keyword">binsof</span>(a) <span class="keyword">intersect</span> &#123;<span class="number">1</span>&#125; &amp;&amp;</span><br><span class="line">          <span class="keyword">binsof</span>(b) <span class="keyword">intersect</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">          <span class="keyword">bins</span> b1 = <span class="keyword">binsof</span>(b) <span class="keyword">intersect</span> &#123;<span class="number">1</span>&#125;; &#125;</span><br><span class="line"><span class="keyword">endgroup</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="覆盖选项">覆盖选项</h3>
<h4 id="单个实例的覆盖率">单个实例的覆盖率</h4>
<ul>
<li>如果对一个covergroup例化多次，那么默认情况下SV会将所有实例的覆盖率合并到一起。如果需要单独列出每个covergroup实例的覆盖率，需要设置覆盖选项</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">covergroup</span> CoverLength;</span><br><span class="line">    <span class="keyword">coverpoint</span> tr<span class="variable">.length</span>;</span><br><span class="line">    option<span class="variable">.per_instance</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">endgroup</span></span><br></pre></td></tr></table></figure>
<hr>
<h4 id="注释">注释</h4>
<ul>
<li>如果有多个covergroup实例，可以通过参数来对每一个实例传入单独的注释。这些注释最终会显示在覆盖率数据的总结报告中</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">covergroup</span> CoverPort(<span class="keyword">int</span> lo,hi, <span class="keyword">string</span> comment);</span><br><span class="line">    option<span class="variable">.comment</span> = comment;</span><br><span class="line">    option<span class="variable">.per_instance</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">coverpoint</span> port &#123;<span class="keyword">bins</span> range = &#123;[lo:hi]&#125;; &#125;</span><br><span class="line"><span class="keyword">endgroup</span></span><br><span class="line">...</span><br><span class="line">CoverPort cp_lo = <span class="keyword">new</span>(<span class="number">0</span>,<span class="number">3</span>, <span class="string">"Low port numbers"</span>);</span><br><span class="line">CoverPort cp_hi = <span class="keyword">new</span>(<span class="number">4</span>,<span class="number">7</span>, <span class="string">"High port numbers"</span>);</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="覆盖次数限定">覆盖次数限定</h4>
<ul>
<li>默认情况下，数值采样了1次就可以计入有效的bin。可以通过修改at_least来修改每个bin的数值最少的采样次数，如果低于at_least数值，则不会被计入bin中</li>
<li>option.at_least可以在covergroup中声明来影响所有的coverpoint，也可以在coverpoint中声明来只影响该coverpoint下所有的bin</li>
</ul>
<hr>
<h4 id="覆盖率目标">覆盖率目标</h4>
<ul>
<li>一个covergroup或者一个coverpoint的目标是100%覆盖率</li>
<li>不过用户也可以将其设置为低于100%的目标。这个选项只会影响覆盖率报告</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">covergroup</span> CoverPort;</span><br><span class="line">    <span class="keyword">coverpoint</span> port;</span><br><span class="line">    option<span class="variable">.goal</span> = <span class="number">90</span>; </span><br><span class="line"><span class="keyword">endgroup</span></span><br></pre></td></tr></table></figure>
<hr>
<h4 id="covergroup方法">covergroup方法</h4>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sample() <span class="comment">// 采样。</span></span><br><span class="line">get_coverage()</span><br><span class="line">get_inst_coverage() <span class="comment">// 获取覆盖率，返回0-100的real数值</span></span><br><span class="line">set_inst_name(<span class="keyword">string</span>) <span class="comment">// 设置covergroup的名称</span></span><br><span class="line">start() <span class="comment">//使能覆盖率的收集</span></span><br><span class="line">stop() <span class="comment">// 关闭覆盖率的收集</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="数据分析">数据分析</h3>
<ul>
<li>使用$get_coverage()可以得到总体的覆盖率</li>
<li>也可以使用covergroup_inst.get_inst_coverage()来获取单个covergroup实例的覆盖率</li>
<li>这些函数最实际的用处是在一个测试当中监测覆盖率的变化</li>
<li>如果覆盖率水平在一段时间之后没有提高，那么这个测试就应该停止</li>
<li>重启新的随机种子或者测试可能有望提高覆盖率</li>
<li>如果测试可以基于功能覆盖率采取一些深入的行动，例如重新限定随机的约束，那将是一件非常好的事情，但是这种测试很难编写</li>
</ul>

      
    </div>
    
    
    

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>坚持原创技术分享，您的支持将鼓励我继续创作！</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechatpay.jpg" alt="Sangrealf 微信支付">
        <p>微信支付</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/alipay.jpg" alt="Sangrealf 支付宝">
        <p>支付宝</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者：</strong>
    Sangrealf
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://www.syq.wiki/2018/03/18/SV-Syntax-Summary/" title="SV Syntax Summary">http://www.syq.wiki/2018/03/18/SV-Syntax-Summary/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>
    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！
  </li>
</ul>

      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/System-Verilog/" rel="tag"># System Verilog</a>
          
            <a href="/tags/SV/" rel="tag"># SV</a>
          
            <a href="/tags/语法/" rel="tag"># 语法</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/08/12/AMBA_start/" rel="prev" title="AMBA学习笔记～基本概念">
                AMBA学习笔记～基本概念 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="lv-container" data-id="city" data-uid="MTAyMC8zNDkzOS8xMTQ3Ng"></div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/touxiang.png" alt="Sangrealf">
            
              <p class="site-author-name" itemprop="name">Sangrealf</p>
              <p class="site-description motion-element" itemprop="description">IC相关读书笔记，个人总结，生活随笔等</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/UVM_Tutorial_for_Candy_Lovers.html">
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/sangrealf" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:yqsang@qq.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          
            <div class="cc-license motion-element" itemprop="license">
              <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" target="_blank">
                <img src="/images/cc-by-nc-sa.svg" alt="Creative Commons">
              </a>
            </div>
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#数据类型"><span class="nav-number">1.</span> <span class="nav-text">数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#定宽数组"><span class="nav-number">1.1.</span> <span class="nav-text">定宽数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#动态数组"><span class="nav-number">1.2.</span> <span class="nav-text">动态数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#队列"><span class="nav-number">1.3.</span> <span class="nav-text">队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关联数组"><span class="nav-number">1.4.</span> <span class="nav-text">关联数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#结构体-枚举-typedef"><span class="nav-number">1.5.</span> <span class="nav-text">结构体、枚举、typedef</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字符串"><span class="nav-number">1.6.</span> <span class="nav-text">字符串</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#design-element"><span class="nav-number">2.</span> <span class="nav-text">Design Element</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#module"><span class="nav-number">2.1.</span> <span class="nav-text">module</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#program"><span class="nav-number">2.2.</span> <span class="nav-text">program</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#interface"><span class="nav-number">2.3.</span> <span class="nav-text">interface</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#checker"><span class="nav-number">2.4.</span> <span class="nav-text">checker</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#primitive"><span class="nav-number">2.5.</span> <span class="nav-text">primitive</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#subroutine"><span class="nav-number">2.6.</span> <span class="nav-text">subroutine</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#task"><span class="nav-number">2.6.1.</span> <span class="nav-text">task</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#function"><span class="nav-number">2.6.2.</span> <span class="nav-text">function</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#package"><span class="nav-number">2.7.</span> <span class="nav-text">package</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#config"><span class="nav-number">2.8.</span> <span class="nav-text">config</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#class"><span class="nav-number">3.</span> <span class="nav-text">class</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#创建对象"><span class="nav-number">3.1.</span> <span class="nav-text">创建对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#verilog的例化和sv-class例化的差别"><span class="nav-number">3.1.1.</span> <span class="nav-text">Verilog的例化和SV class例化的差别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#构造函数"><span class="nav-number">3.1.2.</span> <span class="nav-text">构造函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#静态变量和方法"><span class="nav-number">3.1.3.</span> <span class="nav-text">静态变量和方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类的成员"><span class="nav-number">3.2.</span> <span class="nav-text">类的成员</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类的继承-inheritance"><span class="nav-number">3.3.</span> <span class="nav-text">类的继承(Inheritance)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程的控制和同步"><span class="nav-number">4.</span> <span class="nav-text">线程的控制和同步</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#线程的控制"><span class="nav-number">4.1.</span> <span class="nav-text">线程的控制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程的同步"><span class="nav-number">4.2.</span> <span class="nav-text">线程的同步</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#event事件"><span class="nav-number">4.2.1.</span> <span class="nav-text">event事件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#spmaphore旗语"><span class="nav-number">4.2.2.</span> <span class="nav-text">spmaphore旗语</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#mailbox信箱"><span class="nav-number">4.2.3.</span> <span class="nav-text">mailbox信箱</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#总结"><span class="nav-number">4.2.4.</span> <span class="nav-text">总结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#随机约束"><span class="nav-number">5.</span> <span class="nav-text">随机约束</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#随机化"><span class="nav-number">5.1.</span> <span class="nav-text">随机化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#权重分布"><span class="nav-number">5.2.</span> <span class="nav-text">权重分布</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#集合成员和inside运算符"><span class="nav-number">5.3.</span> <span class="nav-text">集合成员和inside运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#条件约束"><span class="nav-number">5.4.</span> <span class="nav-text">条件约束</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#双向约束"><span class="nav-number">5.5.</span> <span class="nav-text">双向约束</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#约束块控制"><span class="nav-number">5.6.</span> <span class="nav-text">约束块控制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内嵌约束"><span class="nav-number">5.7.</span> <span class="nav-text">内嵌约束</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#随机函数"><span class="nav-number">5.8.</span> <span class="nav-text">随机函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数组约束"><span class="nav-number">5.9.</span> <span class="nav-text">数组约束</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#产生唯一值元素的数组"><span class="nav-number">5.10.</span> <span class="nav-text">产生唯一值元素的数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#随机化句柄数组"><span class="nav-number">5.11.</span> <span class="nav-text">随机化句柄数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#随机序列"><span class="nav-number">5.12.</span> <span class="nav-text">随机序列</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#覆盖率"><span class="nav-number">6.</span> <span class="nav-text">覆盖率</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#覆盖率反馈回路"><span class="nav-number">6.1.</span> <span class="nav-text">覆盖率反馈回路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#代码覆盖率"><span class="nav-number">6.2.</span> <span class="nav-text">代码覆盖率</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#功能覆盖率"><span class="nav-number">6.3.</span> <span class="nav-text">功能覆盖率</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#断言覆盖率"><span class="nav-number">6.4.</span> <span class="nav-text">断言覆盖率</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#验证的策略和完备性"><span class="nav-number">6.5.</span> <span class="nav-text">验证的策略和完备性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#功能覆盖率的策略"><span class="nav-number">6.5.1.</span> <span class="nav-text">功能覆盖率的策略</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#验证的完备性"><span class="nav-number">6.5.2.</span> <span class="nav-text">验证的完备性</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#covergroup"><span class="nav-number">6.6.</span> <span class="nav-text">covergroup</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据采样"><span class="nav-number">6.7.</span> <span class="nav-text">数据采样</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#coverpoint和bin"><span class="nav-number">6.7.1.</span> <span class="nav-text">coverpoint和bin</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#bin的创建和应用"><span class="nav-number">6.7.2.</span> <span class="nav-text">bin的创建和应用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#条件覆盖率"><span class="nav-number">6.7.3.</span> <span class="nav-text">条件覆盖率</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#翻转覆盖率"><span class="nav-number">6.7.4.</span> <span class="nav-text">翻转覆盖率</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#wildcard覆盖率"><span class="nav-number">6.7.5.</span> <span class="nav-text">wildcard覆盖率</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#忽略的bin"><span class="nav-number">6.7.6.</span> <span class="nav-text">忽略的bin</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#非法的bin"><span class="nav-number">6.7.7.</span> <span class="nav-text">非法的bin</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#交叉覆盖率"><span class="nav-number">6.7.8.</span> <span class="nav-text">交叉覆盖率</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#排除部分cross-bin"><span class="nav-number">6.7.9.</span> <span class="nav-text">排除部分cross bin</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#精细的交叉覆盖率指定"><span class="nav-number">6.7.10.</span> <span class="nav-text">精细的交叉覆盖率指定</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#覆盖选项"><span class="nav-number">6.8.</span> <span class="nav-text">覆盖选项</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#单个实例的覆盖率"><span class="nav-number">6.8.1.</span> <span class="nav-text">单个实例的覆盖率</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#注释"><span class="nav-number">6.8.2.</span> <span class="nav-text">注释</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#覆盖次数限定"><span class="nav-number">6.8.3.</span> <span class="nav-text">覆盖次数限定</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#覆盖率目标"><span class="nav-number">6.8.4.</span> <span class="nav-text">覆盖率目标</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#covergroup方法"><span class="nav-number">6.8.5.</span> <span class="nav-text">covergroup方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据分析"><span class="nav-number">6.9.</span> <span class="nav-text">数据分析</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
            <span id="scrollpercent"><span>0</span>%</span>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Sangrealf</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>








        
      </div>
    </footer>

    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  
    <script type="text/javascript">
      (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>
  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
